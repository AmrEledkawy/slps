<xbgf:sequence
  xmlns:bgf="http://planet-sl.org/bgf"
  xmlns:xbgf="http://planet-sl.org/xbgf">

  <!--
  Expressions in the syntax appendix look like this:
  
  InterfaceDeclaration is defined as:
     NormalInterfaceDeclaration
     AnnotationTypeDeclaration
  NormalInterfaceDeclaration is defined as:
     "interface" Identifier [ TypeParameters ] [ "extends" TypeList ] InterfaceBody
  InterfaceBody is defined as:
     "{" { InterfaceBodyDeclaration } "}"
  InterfaceBodyDeclaration is defined as:
     ";"
     ModifiersOpt InterfaceMemberDecl
  InterfaceMemberDecl is defined as:
     InterfaceMethodOrFieldDecl
     "void" Identifier VoidInterfaceMethodDeclaratorRest
     ClassOrInterfaceDeclaration
  InterfaceMethodOrFieldDecl is defined as:
     Type Identifier InterfaceMethodOrFieldRest
  InterfaceMethodOrFieldRest is defined as:
     ConstantDeclaratorsRest ";"
     InterfaceMethodDeclaratorRest
  ConstantDeclaratorsRest is defined as:
     ConstantDeclaratorRest { "," ConstantDeclarator }
  InterfaceMethodDeclaratorRest is defined as:
     FormalParameters BracketsOpt [ "throws" QualifiedIdentifierList ] ";"
  VoidInterfaceMethodDeclaratorRest is defined as:
     FormalParameters [ "throws" QualifiedIdentifierList ] ";"


  While in the text of the spec it is yaccified:

  InterfaceDeclaration is defined as:
     NormalInterfaceDeclaration
     AnnotationTypeDeclaration
  NormalInterfaceDeclaration is defined as:
     [ InterfaceModifiers ] "interface" Identifier [ ExtendsInterfaces ] InterfaceBody
  ExtendsInterfaces is defined as:
     "extends" InterfaceType
     ExtendsInterfaces "," InterfaceType
  InterfaceBody is defined as:
     { [ InterfaceMemberDeclarations ] }
  InterfaceMemberDeclarations is defined as:
     InterfaceMemberDeclaration
     InterfaceMemberDeclarations InterfaceMemberDeclaration
  InterfaceMemberDeclaration is defined as:
     ConstantDeclaration
     AbstractMethodDeclaration
     ClassDeclaration
     InterfaceDeclaration
     ";"
  ConstantDeclaration is defined as:
     [ ConstantModifiers ] Type VariableDeclarators
  AbstractMethodDeclaration is defined as:
     [ AbstractMethodModifiers ] ResultType MethodDeclarator [ Throws ] ";"
  MethodDeclarator is defined as:
     Identifier "(" [ FormalParameterList ] ")"
 -->

  <!-- BREFACTOR 
   - Fail: NormalInterfaceDeclaration.
      - [], ,([t(interface), n(Identifier), ?(,([t(extends), n(TypeList)])), n(InterfaceBody)])
     vs.
      - [], ,([n(ModifiersOpt), t(interface), n(Identifier), ?(n(ExtendsInterfaces)), n(InterfaceBody)])
  -->
  <xbgf:project>
    <bgf:production>
      <nonterminal>NormalInterfaceDeclaration</nonterminal>
      <bgf:expression>
        <sequence>
          <bgf:expression>
            <terminal>interface</terminal>
          </bgf:expression>
          <bgf:expression>
            <nonterminal>Identifier</nonterminal>
          </bgf:expression>
          <bgf:expression>
            <optional>
              <bgf:expression>
                <nonterminal>ExtendsInterfaces</nonterminal>
              </bgf:expression>
            </optional>
          </bgf:expression>
          <bgf:expression>
            <nonterminal>InterfaceBody</nonterminal>
          </bgf:expression>
        </sequence>
      </bgf:expression>
    </bgf:production>
  </xbgf:project>
  <xbgf:deyaccify>ExtendsInterfaces</xbgf:deyaccify>
  <xbgf:fold>
    <nonterminal>TypeList</nonterminal>
    <in>
      <nonterminal>ExtendsInterfaces</nonterminal>
    </in>
  </xbgf:fold>

  <!-- BREFACTOR 
     - Fail: NormalInterfaceDeclaration.
      - [], ,([t(interface), n(Identifier), ?(n(TypeParameters)), ?(,([t(extends), n(TypeList)])), n(InterfaceBody)])
     vs.
      - [], ,([t(interface), n(Identifier), ?(,([t(extends), n(TypeList)])), n(InterfaceBody)])
-->
  <xbgf:inject>
    <bgf:production>
      <nonterminal>NormalInterfaceDeclaration</nonterminal>
      <bgf:expression>
        <sequence>
          <bgf:expression>
            <terminal>interface</terminal>
          </bgf:expression>
          <bgf:expression>
            <nonterminal>Identifier</nonterminal>
          </bgf:expression>
          <bgf:expression>
            <optional>
              <bgf:expression>
                <nonterminal>TypeParameters</nonterminal>
              </bgf:expression>
            </optional>
          </bgf:expression>
          <bgf:expression>
            <optional>
              <bgf:expression>
                <nonterminal>ExtendsInterfaces</nonterminal>
              </bgf:expression>
            </optional>
          </bgf:expression>
          <bgf:expression>
            <nonterminal>InterfaceBody</nonterminal>
          </bgf:expression>
        </sequence>
      </bgf:expression>
    </bgf:production>
  </xbgf:inject>
  <xbgf:inline>ExtendsInterfaces</xbgf:inline>

  <!-- 
   - Fail: InterfaceBody.
      - [], ,([t({), *(n(InterfaceBodyDeclaration)), t(})])
     vs.
      - [], ,([t({), ?(n(InterfaceMemberDeclarations)), t(})])
  -->
  <xbgf:deyaccify>InterfaceMemberDeclarations</xbgf:deyaccify>
  <xbgf:inline>InterfaceMemberDeclarations</xbgf:inline>
  <xbgf:rename>
    <nonterminal>
      <from>InterfaceMemberDeclaration</from>
      <to>InterfaceBodyDeclaration</to>
    </nonterminal>
  </xbgf:rename>
  <xbgf:massage>
    <bgf:expression>
      <optional>
        <bgf:expression>
          <plus>
            <bgf:expression>
              <nonterminal>InterfaceBodyDeclaration</nonterminal>
            </bgf:expression>
          </plus>
        </bgf:expression>
      </optional>
    </bgf:expression>
    <bgf:expression>
      <star>
        <bgf:expression>
          <nonterminal>InterfaceBodyDeclaration</nonterminal>
        </bgf:expression>
      </star>
    </bgf:expression>
  </xbgf:massage>

  <!-- 
   - Fail: InterfaceBodyDeclaration.
      - [], ;([t((;)), ,([*(n(Modifier)), n(InterfaceMemberDecl)])])
     vs.
      - [], ;([n(ConstantDeclaration), n(AbstractMethodDeclaration), n(ClassDeclaration), n(InterfaceDeclaration), t((;))])
  -->
  <xbgf:inline>ConstantDeclaration</xbgf:inline>
  <xbgf:inline>AbstractMethodDeclaration</xbgf:inline>

  <xbgf:vertical>
    <nonterminal>InterfaceBodyDeclaration</nonterminal>
  </xbgf:vertical>

  <!-- modifiers -->
  <xbgf:designate>
    <bgf:production>
      <label>target</label>
      <nonterminal>InterfaceBodyDeclaration</nonterminal>
      <bgf:expression>
        <nonterminal>ClassDeclaration</nonterminal>
      </bgf:expression>
    </bgf:production>
  </xbgf:designate>
  <!-- BREFACTOR -->
  <xbgf:inject>
    <bgf:production>
      <label>target</label>
      <nonterminal>InterfaceBodyDeclaration</nonterminal>
      <bgf:expression>
        <sequence>
          <bgf:expression>
            <nonterminal>ModifiersOpt</nonterminal>
          </bgf:expression>
          <bgf:expression>
            <nonterminal>ClassDeclaration</nonterminal>
          </bgf:expression>
        </sequence>
      </bgf:expression>
    </bgf:production>
  </xbgf:inject>
  <xbgf:strip>
    <label>target</label>
  </xbgf:strip>
  <xbgf:designate>
    <bgf:production>
      <label>target</label>
      <nonterminal>InterfaceBodyDeclaration</nonterminal>
      <bgf:expression>
        <nonterminal>InterfaceDeclaration</nonterminal>
      </bgf:expression>
    </bgf:production>
  </xbgf:designate>
  <!-- BREFACTOR -->
  <xbgf:inject>
    <bgf:production>
      <label>target</label>
      <nonterminal>InterfaceBodyDeclaration</nonterminal>
      <bgf:expression>
        <sequence>
          <bgf:expression>
            <nonterminal>ModifiersOpt</nonterminal>
          </bgf:expression>
          <bgf:expression>
            <nonterminal>InterfaceDeclaration</nonterminal>
          </bgf:expression>
        </sequence>
      </bgf:expression>
    </bgf:production>
  </xbgf:inject>
  <xbgf:strip>
    <label>target</label>
  </xbgf:strip>

  <!-- 
   - Fail: Annotations.
      - [], ,([n(Annotation), ?(n(Annotations))])
     vs.
      - [], ;([n(Annotation), ,([n(Annotations), n(Annotation)])])
  -->
  <xbgf:deyaccify>Annotations</xbgf:deyaccify>

  <!-- BREFACTOR 
   - Fail: AnnotationTypeDeclaration.
      - [], ,([t(@), t(interface), n(Identifier), n(AnnotationTypeBody)])
     vs.
      - [], ,([*(n(Modifier)), t(@), t(interface), n(Identifier), n(AnnotationTypeBody)])
  -->
  <xbgf:project>
    <bgf:production>
      <nonterminal>AnnotationTypeDeclaration</nonterminal>
      <bgf:expression>
        <sequence>
          <bgf:expression>
            <terminal>@</terminal>
          </bgf:expression>
          <bgf:expression>
            <terminal>interface</terminal>
          </bgf:expression>
          <bgf:expression>
            <nonterminal>Identifier</nonterminal>
          </bgf:expression>
          <bgf:expression>
            <nonterminal>AnnotationTypeBody</nonterminal>
          </bgf:expression>
        </sequence>
      </bgf:expression>
    </bgf:production>
  </xbgf:project>

  <!-- 
   This is needed for Annotation (see below)
      
  ElementValuePairs is defined as:
     ElementValuePair
     ElementValuePairs "," ElementValuePair
  
  so we effectively "narrow" it (by executing remove instead of deyaccify/narrow)
  (also because narrow(*(L),true) doesn't work)
  -->
  <xbgf:vertical>
    <nonterminal>ElementValuePairs</nonterminal>
  </xbgf:vertical>
  <xbgf:remove>
    <bgf:production>
      <nonterminal>ElementValuePairs</nonterminal>
      <bgf:expression>
        <sequence>
          <bgf:expression>
            <nonterminal>ElementValuePairs</nonterminal>
          </bgf:expression>
          <bgf:expression>
            <terminal>,</terminal>
          </bgf:expression>
          <bgf:expression>
            <nonterminal>ElementValuePair</nonterminal>
          </bgf:expression>
        </sequence>
      </bgf:expression>
    </bgf:production>
  </xbgf:remove>
  <xbgf:inline>ElementValuePairs</xbgf:inline>
  
  <!-- 
   - Fail: Annotation.
      - [], ,([t(@), n(TypeName), ?(,([t((), ?(,([n(Identifier), t(=)])), n(ElementValue), t())]))])
     vs.
      - [], ;([n(NormalAnnotation), n(MarkerAnnotation), n(SingleElementAnnotation)])
  -->
  <xbgf:inline>NormalAnnotation</xbgf:inline>
  <xbgf:inline>MarkerAnnotation</xbgf:inline>
  <xbgf:inline>SingleElementAnnotation</xbgf:inline>
  <xbgf:inline>ElementValuePair</xbgf:inline>

  <!-- 
  The following solution breaks semantics by disallowing
  ,([t(@), n(QualifiedIdentifier), t((), t())])
  
   - Fail: Annotation.
      - [], ,([t(@), n(QualifiedIdentifier), ?(,([t((), ?(,([n(Identifier), t(=)])), n(ElementValue), t())]))])
     vs.
   - [], ;([,([t(@), n(QualifiedIdentifier), t((), ?(,([n(Identifier), t(=), n(ElementValue)])), t())]),
            ,([t(@), n(QualifiedIdentifier)]),
            ,([t(@), n(QualifiedIdentifier), t((), n(ElementValue), t())])])
  -->
  <xbgf:massage>
    <bgf:expression>
      <optional>
        <bgf:expression>
          <sequence>
            <bgf:expression>
              <nonterminal>Identifier</nonterminal>
            </bgf:expression>
            <bgf:expression>
              <terminal>=</terminal>
            </bgf:expression>
            <bgf:expression>
              <nonterminal>ElementValue</nonterminal>
            </bgf:expression>
          </sequence>
        </bgf:expression>
      </optional>
    </bgf:expression>
    <bgf:expression>
      <choice>
        <bgf:expression>
          <sequence>
            <bgf:expression>
              <nonterminal>Identifier</nonterminal>
            </bgf:expression>
            <bgf:expression>
              <terminal>=</terminal>
            </bgf:expression>
            <bgf:expression>
              <nonterminal>ElementValue</nonterminal>
            </bgf:expression>
          </sequence>
        </bgf:expression>
        <bgf:expression>
          <epsilon/>
        </bgf:expression>
      </choice>
    </bgf:expression>
  </xbgf:massage>
  <xbgf:distribute>
    <nonterminal>Annotation</nonterminal>
  </xbgf:distribute>
  <xbgf:vertical>
    <nonterminal>Annotation</nonterminal>
  </xbgf:vertical>
  <xbgf:remove>
    <bgf:production>
      <nonterminal>Annotation</nonterminal>
      <bgf:expression>
        <sequence>
          <bgf:expression>
            <terminal>@</terminal>
          </bgf:expression>
          <bgf:expression>
            <nonterminal>QualifiedIdentifier</nonterminal>
          </bgf:expression>
          <bgf:expression>
            <terminal>(</terminal>
          </bgf:expression>
          <bgf:expression>
            <terminal>)</terminal>
          </bgf:expression>
        </sequence>
      </bgf:expression>
    </bgf:production>
  </xbgf:remove>
  <xbgf:horizontal>Annotation</xbgf:horizontal>
  <xbgf:factor>
    <bgf:expression>
      <choice>
        <bgf:expression>
          <sequence>
            <bgf:expression>
              <terminal>@</terminal>
            </bgf:expression>
            <bgf:expression>
              <nonterminal>QualifiedIdentifier</nonterminal>
            </bgf:expression>
            <bgf:expression>
              <terminal>(</terminal>
            </bgf:expression>
            <bgf:expression>
              <nonterminal>Identifier</nonterminal>
            </bgf:expression>
            <bgf:expression>
              <terminal>=</terminal>
            </bgf:expression>
            <bgf:expression>
              <nonterminal>ElementValue</nonterminal>
            </bgf:expression>
            <bgf:expression>
              <terminal>)</terminal>
            </bgf:expression>
          </sequence>
        </bgf:expression>
        <bgf:expression>
          <sequence>
            <bgf:expression>
              <terminal>@</terminal>
            </bgf:expression>
            <bgf:expression>
              <nonterminal>QualifiedIdentifier</nonterminal>
            </bgf:expression>
          </sequence>
        </bgf:expression>
        <bgf:expression>
          <sequence>
            <bgf:expression>
              <terminal>@</terminal>
            </bgf:expression>
            <bgf:expression>
              <nonterminal>QualifiedIdentifier</nonterminal>
            </bgf:expression>
            <bgf:expression>
              <terminal>(</terminal>
            </bgf:expression>
            <bgf:expression>
              <nonterminal>ElementValue</nonterminal>
            </bgf:expression>
            <bgf:expression>
              <terminal>)</terminal>
            </bgf:expression>
          </sequence>
        </bgf:expression>
      </choice>
    </bgf:expression>
    <bgf:expression>
      <sequence>
        <bgf:expression>
          <terminal>@</terminal>
        </bgf:expression>
        <bgf:expression>
          <nonterminal>QualifiedIdentifier</nonterminal>
        </bgf:expression>
        <bgf:expression>
          <choice>
            <bgf:expression>
              <sequence>
                <bgf:expression>
                  <terminal>(</terminal>
                </bgf:expression>
                <bgf:expression>
                  <choice>
                    <bgf:expression>
                      <sequence>
                        <bgf:expression>
                          <nonterminal>Identifier</nonterminal>
                        </bgf:expression>
                        <bgf:expression>
                          <terminal>=</terminal>
                        </bgf:expression>
                      </sequence>
                    </bgf:expression>
                    <bgf:expression>
                      <epsilon/>
                    </bgf:expression>
                  </choice>
                </bgf:expression>
                <bgf:expression>
                  <nonterminal>ElementValue</nonterminal>
                </bgf:expression>
                <bgf:expression>
                  <terminal>)</terminal>
                </bgf:expression>
              </sequence>
            </bgf:expression>
            <bgf:expression>
              <epsilon/>
            </bgf:expression>
          </choice>
        </bgf:expression>
      </sequence>
    </bgf:expression>
  </xbgf:factor>
  <xbgf:massage>
    <bgf:expression>
      <choice>
        <bgf:expression>
          <sequence>
            <bgf:expression>
              <nonterminal>Identifier</nonterminal>
            </bgf:expression>
            <bgf:expression>
              <terminal>=</terminal>
            </bgf:expression>
          </sequence>
        </bgf:expression>
        <bgf:expression>
          <epsilon/>
        </bgf:expression>
      </choice>
    </bgf:expression>
    <bgf:expression>
      <optional>
        <bgf:expression>
          <sequence>
            <bgf:expression>
              <nonterminal>Identifier</nonterminal>
            </bgf:expression>
            <bgf:expression>
              <terminal>=</terminal>
            </bgf:expression>
          </sequence>
        </bgf:expression>
      </optional>
    </bgf:expression>
  </xbgf:massage>
  <xbgf:massage>
    <bgf:expression>
      <choice>
        <bgf:expression>
          <sequence>
            <bgf:expression>
              <terminal>(</terminal>
            </bgf:expression>
            <bgf:expression>
              <optional>
                <bgf:expression>
                  <sequence>
                    <bgf:expression>
                      <nonterminal>Identifier</nonterminal>
                    </bgf:expression>
                    <bgf:expression>
                      <terminal>=</terminal>
                    </bgf:expression>
                  </sequence>
                </bgf:expression>
              </optional>
            </bgf:expression>
            <bgf:expression>
              <nonterminal>ElementValue</nonterminal>
            </bgf:expression>
            <bgf:expression>
              <terminal>)</terminal>
            </bgf:expression>
          </sequence>
        </bgf:expression>
        <bgf:expression>
          <epsilon/>
        </bgf:expression>
      </choice>
    </bgf:expression>
    <bgf:expression>
      <optional>
        <bgf:expression>
          <sequence>
            <bgf:expression>
              <terminal>(</terminal>
            </bgf:expression>
            <bgf:expression>
              <optional>
                <bgf:expression>
                  <sequence>
                    <bgf:expression>
                      <nonterminal>Identifier</nonterminal>
                    </bgf:expression>
                    <bgf:expression>
                      <terminal>=</terminal>
                    </bgf:expression>
                  </sequence>
                </bgf:expression>
              </optional>
            </bgf:expression>
            <bgf:expression>
              <nonterminal>ElementValue</nonterminal>
            </bgf:expression>
            <bgf:expression>
              <terminal>)</terminal>
            </bgf:expression>
          </sequence>
        </bgf:expression>
      </optional>
    </bgf:expression>
  </xbgf:massage>
  
  <!-- ISSUE PERMISSIVENESS
  ExceptionTypeList vs QualifiedIdentifierList -->
  <!-- GENERALITY -->
  <xbgf:undefine>ExceptionTypeList</xbgf:undefine>
  <xbgf:unite>
    <add>ExceptionTypeList</add>
    <to>QualifiedIdentifierList</to>
  </xbgf:unite>
  <xbgf:inline>Throws</xbgf:inline>

  <!--
  can't match right away because one is left recursion and the other one is right
  
  - Fail: ElementValues.
      - [], ,([n('ElementValue'), ?(,([t((',')), n('ElementValues')]))])
     vs.
      - [], ;([n('ElementValue'), ,([n('ElementValues'), t((',')), n('ElementValue')])])
  -->
  <xbgf:deyaccify>ElementValues</xbgf:deyaccify>
  <!-- can be yaccify after yaccify2 test case works -->
  <!-- BREFACTOR -->
  <xbgf:undefine>ElementValues</xbgf:undefine>
  <!-- BREFACTOR -->
  <xbgf:define>
    <bgf:production>
      <nonterminal>ElementValues</nonterminal>
      <bgf:expression>
        <choice>
          <bgf:expression>
            <nonterminal>ElementValue</nonterminal>
          </bgf:expression>
          <bgf:expression>
            <sequence>
              <bgf:expression>
                <nonterminal>ElementValue</nonterminal>
              </bgf:expression>
              <bgf:expression>
                <terminal>,</terminal>
              </bgf:expression>
              <bgf:expression>
                <nonterminal>ElementValues</nonterminal>
              </bgf:expression>
            </sequence>
          </bgf:expression>
        </choice>
      </bgf:expression>
    </bgf:production>
  </xbgf:define>
  <!-- end of future yaccify -->
  <xbgf:factor>
    <bgf:expression>
      <choice>
        <bgf:expression>
          <nonterminal>ElementValue</nonterminal>
        </bgf:expression>
        <bgf:expression>
          <sequence>
            <bgf:expression>
              <nonterminal>ElementValue</nonterminal>
            </bgf:expression>
            <bgf:expression>
              <terminal>,</terminal>
            </bgf:expression>
            <bgf:expression>
              <nonterminal>ElementValues</nonterminal>
            </bgf:expression>
          </sequence>
        </bgf:expression>
      </choice>
    </bgf:expression>
    <bgf:expression>
      <sequence>
        <bgf:expression>
          <nonterminal>ElementValue</nonterminal>
        </bgf:expression>
        <bgf:expression>
          <choice>
            <bgf:expression>
              <sequence>
                <bgf:expression>
                  <terminal>,</terminal>
                </bgf:expression>
                <bgf:expression>
                  <nonterminal>ElementValues</nonterminal>
                </bgf:expression>
              </sequence>
            </bgf:expression>
            <bgf:expression>
              <epsilon/>
            </bgf:expression>
          </choice>
        </bgf:expression>
      </sequence>
    </bgf:expression>
  </xbgf:factor>
  <xbgf:massage>
    <bgf:expression>
      <choice>
        <bgf:expression>
          <sequence>
            <bgf:expression>
              <terminal>,</terminal>
            </bgf:expression>
            <bgf:expression>
              <nonterminal>ElementValues</nonterminal>
            </bgf:expression>
          </sequence>
        </bgf:expression>
        <bgf:expression>
          <epsilon/>
        </bgf:expression>
      </choice>
    </bgf:expression>
    <bgf:expression>
      <optional>
        <bgf:expression>
          <sequence>
            <bgf:expression>
              <terminal>,</terminal>
            </bgf:expression>
            <bgf:expression>
              <nonterminal>ElementValues</nonterminal>
            </bgf:expression>
          </sequence>
        </bgf:expression>
      </optional>
    </bgf:expression>
  </xbgf:massage>
  
  <xbgf:fold>
    <nonterminal>BracketsOpt</nonterminal>
  </xbgf:fold>
  
  <!-- 
   - Fail: ImportDeclaration.
      - [], ,([t(import), ?(t(static)), n(Identifier), *(,([t(.), n(Identifier)])), ?(,([t(.), t(*)])), t((;))])
     vs.
      - [], ;([,([t(import), n(QualifiedIdentifier), ?(,([t(.), t(*)])), t((;))]), n(SingleStaticImportDeclaration), n(StaticImportOnDemandDeclaration)])
  -->
  <xbgf:inline>SingleStaticImportDeclaration</xbgf:inline>
  <xbgf:inline>StaticImportOnDemandDeclaration</xbgf:inline>
  
</xbgf:sequence>