compilationUnit : (packageDefinition | EPSILON) importDefinition* typeDefinition* ;
packageDefinition : annotations "package" identifier SEMI ;
annotations : annotation* ;
annotation : AT identifier annotationInit ;
AT : "@" ;
identifier : IDENT (DOT IDENT)* ;
IDENT : ("a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" | "_" | "$") ("a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" | "_" | "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "$")* ;
DOT : "." ;
annotationInit : LPAREN ((annotationMemberInit (COMMA annotationMemberInit)*) | annotationMemberValue | EPSILON) RPAREN | EPSILON ;
LPAREN : "(" ;
annotationMemberInit : IDENT ASSIGN annotationMemberValue ;
ASSIGN : "=" ;
annotationMemberValue : annotation | conditionalExpression | annotationMemberArrayInitializer ;
conditionalExpression : logicalOrExpression (QUESTION assignmentExpression COLON conditionalExpression)? ;
logicalOrExpression : logicalAndExpression (LOR logicalAndExpression)* ;
logicalAndExpression : inclusiveOrExpression (LAND inclusiveOrExpression)* ;
inclusiveOrExpression : exclusiveOrExpression (BOR exclusiveOrExpression)* ;
exclusiveOrExpression : andExpression (BXOR andExpression)* ;
andExpression : equalityExpression (BAND equalityExpression)* ;
equalityExpression : relationalExpression ((NOT_EQUAL | EQUAL) relationalExpression)* ;
relationalExpression : shiftExpression (((LT | GT | LE | GE) shiftExpression)* | ("instanceof" typeSpec)) ;
shiftExpression : additiveExpression ((SL | SR | BSR) additiveExpression)* ;
additiveExpression : multiplicativeExpression ((PLUS | MINUS) multiplicativeExpression)* ;
multiplicativeExpression : unaryExpression ((STAR | DIV | MOD) unaryExpression)* ;
unaryExpression : INC unaryExpression | DEC unaryExpression | MINUS unaryExpression | PLUS unaryExpression | unaryExpressionNotPlusMinus ;
INC : "++" ;
DEC : "--" ;
MINUS : "-" ;
PLUS : "+" ;
unaryExpressionNotPlusMinus : BNOT unaryExpression | LNOT unaryExpression | LPAREN builtInTypeSpec RPAREN unaryExpression | LPAREN classTypeSpec RPAREN unaryExpressionNotPlusMinus | postfixExpression ;
BNOT : "~" ;
LNOT : "!" ;
builtInTypeSpec : builtInType (LBRACK RBRACK)* ;
builtInType : "void" | "boolean" | "byte" | "char" | "short" | "int" | "float" | "long" | "double" ;
LBRACK : "[" ;
RBRACK : "]" ;
RPAREN : ")" ;
classTypeSpec : classOrInterfaceType (LBRACK RBRACK)* ;
classOrInterfaceType : IDENT typeArguments (DOT IDENT typeArguments)* ;
typeArguments : LT typeArgument (COMMA typeArgument)* typeArgumentsEnd? | EPSILON ;
LT : "<" ;
typeArgument : QUESTION (("extends" referenceTypeSpec) | ("super" referenceTypeSpec))? | referenceTypeSpec ;
QUESTION : "?" ;
referenceTypeSpec : classTypeSpec | arrayTypeSpec ;
arrayTypeSpec : builtInType (LBRACK RBRACK)+ ;
COMMA : "," ;
typeArgumentsEnd : GT | SR | BSR ;
GT : ">" ;
SR : ">>" ;
BSR : ">>>" ;
postfixExpression : primaryExpression ((DOT "this") | (DOT typeArguments ((IDENT (LPAREN argList RPAREN)?) | ("super" ((LPAREN argList RPAREN) | (DOT typeArguments IDENT (LPAREN argList RPAREN)?))))) | (DOT newExpression) | (LBRACK expression RBRACK))* (INC | DEC)? ;
primaryExpression : identPrimary (DOT "class")? | constant | "true" | "false" | "null" | newExpression | "this" | "super" | LPAREN assignmentExpression RPAREN | builtInType (LBRACK RBRACK)* DOT "class" ;
identPrimary : typeArguments IDENT ((DOT typeArguments IDENT) | EPSILON)* ((LPAREN argList RPAREN) | (LBRACK RBRACK)+)? ;
argList : expressionList | EPSILON ;
expressionList : expression (COMMA expression)* ;
expression : assignmentExpression ;
assignmentExpression : conditionalExpression ((ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | STAR_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | SR_ASSIGN | BSR_ASSIGN | SL_ASSIGN | BAND_ASSIGN | BXOR_ASSIGN | BOR_ASSIGN) assignmentExpression)? ;
PLUS_ASSIGN : "+=" ;
MINUS_ASSIGN : "-=" ;
STAR_ASSIGN : "*=" ;
DIV_ASSIGN : "/=" ;
MOD_ASSIGN : "%=" ;
SR_ASSIGN : ">>=" ;
BSR_ASSIGN : ">>>=" ;
SL_ASSIGN : "<<=" ;
BAND_ASSIGN : "&=" ;
BXOR_ASSIGN : "^=" ;
BOR_ASSIGN : "|=" ;
constant : NUM_INT | CHAR_LITERAL | STRING_LITERAL | NUM_FLOAT | NUM_LONG | NUM_DOUBLE ;
NUM_INT : "." (("." ".") | (("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ EXPONENT? FLOAT_SUFFIX?)?) | (("0" ((("x" | "X") HEX_DIGIT+) | ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ | ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7")+)?) | (("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9") ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")*)) ("l" | "L" | ("." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* EXPONENT? FLOAT_SUFFIX?) | (EXPONENT FLOAT_SUFFIX?) | FLOAT_SUFFIX)? ;
EXPONENT : ("e" | "E") ("+" | "-")? ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ;
FLOAT_SUFFIX : "f" | "F" | "d" | "D" ;
HEX_DIGIT : "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "A" | "B" | "C" | "D" | "E" | "F" | "a" | "b" | "c" | "d" | "e" | "f" ;
CHAR_LITERAL : "\'" (ESC | STR) "\'" ;
ESC : "\\" ("n" | "r" | "t" | "b" | "f" | QUOTES3 | "\'" | "\\" | ("u"+ HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT) | (("0" | "1" | "2" | "3") (("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7") ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7")?)?) | (("4" | "5" | "6" | "7") ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7")?)) ;
STRING_LITERAL : QUOTES3 (ESC | STR)* QUOTES3 ;
NUM_FLOAT : "." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ EXPONENT? ("f" | "F") | "0" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ("." | EXPONENT | "f" | "F") | ("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* ((("." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")*)? EXPONENT? ("f" | "F")) | EXPONENT) ;
NUM_LONG : ("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* ("l" | "L") ;
NUM_DOUBLE : "." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ EXPONENT? ("d" | "D") | "0" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ("." | EXPONENT | "d" | "D") | ("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* ((("." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")*)? EXPONENT? ("d" | "D")) | EXPONENT) ;
newExpression : "new" typeArguments type ((LPAREN argList RPAREN classBlock?) | (newArrayDeclarator arrayInitializer?)) ;
type : classOrInterfaceType | builtInType ;
classBlock : LCURLY (classField | SEMI)* RCURLY ;
LCURLY : "{" ;
classField : modifiers (innerTypeDef | (typeParameters ((ctorHead constructorBody) | memberDef))) | "static" compoundStatement | compoundStatement ;
modifiers : (modifier | annotation)* ;
modifier : "private" | "public" | "protected" | "static" | "transient" | "final" | "abstract" | "native" | "threadsafe" | "synchronized" | "volatile" | "strictfp" ;
innerTypeDef : enumDefinition | classDefinition | interfaceDefinition | annotationTypeDefinition ;
enumDefinition : ENUM IDENT implementsClause enumBlock ;
ENUM : "enum" ;
implementsClause : ("implements" classOrInterfaceType (COMMA classOrInterfaceType)*)? ;
enumBlock : LCURLY (enumConst (COMMA enumConst)*)? COMMA? (SEMI (classField | SEMI)*)? RCURLY ;
enumConst : annotations IDENT enumConstInit classBlock? ;
enumConstInit : LPAREN argList RPAREN | EPSILON ;
SEMI : ";" ;
RCURLY : "}" ;
classDefinition : "class" IDENT typeParameters superClassClause implementsClause classBlock ;
typeParameters : LT typeParameter (COMMA typeParameter)* typeArgumentsEnd? | EPSILON ;
typeParameter : IDENT ("extends" classOrInterfaceType (BAND classOrInterfaceType)*)? ;
BAND : "&" ;
superClassClause : ("extends" classOrInterfaceType)? ;
interfaceDefinition : "interface" IDENT typeParameters interfaceExtends interfaceBlock ;
interfaceExtends : ("extends" classOrInterfaceType (COMMA classOrInterfaceType)*)? ;
interfaceBlock : LCURLY (interfaceField | SEMI)* RCURLY ;
interfaceField : modifiers (innerTypeDef | (typeParameters memberDef)) ;
memberDef : typeSpec ((IDENT LPAREN parameterDeclarationList RPAREN declaratorBrackets throwsClause? (SEMI | compoundStatement)) | (variableDefinitions SEMI)) ;
typeSpec : classTypeSpec | builtInTypeSpec ;
parameterDeclarationList : (parameterDeclaration (COMMA parameterDeclaration)*)? ;
parameterDeclaration : parameterModifier typeSpec ELLIPSIS? IDENT declaratorBrackets ;
parameterModifier : ("final" | annotation)* ;
ELLIPSIS : "..." ;
declaratorBrackets : (LBRACK RBRACK)* ;
throwsClause : "throws" identifier (COMMA identifier)* ;
compoundStatement : LCURLY statement* RCURLY ;
statement : compoundStatement | declaration SEMI | expression SEMI | modifiers (enumDefinition | classDefinition) | IDENT COLON statement | "if" LPAREN expression RPAREN statement ("else" statement)? | "for" LPAREN ((parameterDeclaration COLON expression) | (forInit SEMI forCond SEMI forIter)) RPAREN statement | "while" LPAREN expression RPAREN statement | "do" statement "while" LPAREN expression RPAREN SEMI | "break" IDENT? SEMI | "continue" IDENT? SEMI | "return" expression? SEMI | "switch" LPAREN expression RPAREN LCURLY casesGroup* RCURLY | tryBlock | "throw" expression SEMI | "synchronized" LPAREN expression RPAREN compoundStatement | ASSERT expression (COLON expression)? SEMI | SEMI ;
declaration : modifiers typeSpec variableDefinitions ;
variableDefinitions : variableDeclarator (COMMA variableDeclarator)* ;
variableDeclarator : IDENT declaratorBrackets varInitializer ;
varInitializer : (ASSIGN initializer)? ;
initializer : expression | arrayInitializer ;
arrayInitializer : LCURLY (initializer (COMMA initializer)*)? COMMA? RCURLY ;
COLON : ":" ;
forInit : (declaration | expressionList)? ;
forCond : expression? ;
forIter : expressionList? ;
casesGroup : aCase+ caseSList ;
aCase : (("case" expression) | "default") COLON ;
caseSList : statement* ;
tryBlock : "try" compoundStatement handler* finallyClause? ;
handler : "catch" LPAREN parameterDeclaration RPAREN compoundStatement ;
finallyClause : "finally" compoundStatement ;
ASSERT : "assert" ;
annotationTypeDefinition : AT "interface" IDENT annotationBlock ;
annotationBlock : LCURLY (annotationField | SEMI)* RCURLY ;
annotationField : modifiers (innerTypeDef | (typeSpec ((IDENT LPAREN RPAREN defaultValue SEMI) | (variableDefinitions SEMI)))) ;
defaultValue : ("default" annotationMemberValue)? ;
ctorHead : IDENT LPAREN parameterDeclarationList RPAREN throwsClause? ;
constructorBody : LCURLY explicitConstructorInvocation? statement* RCURLY ;
explicitConstructorInvocation : typeArguments (("this" LPAREN argList RPAREN SEMI) | ("super" LPAREN argList RPAREN SEMI)) ;
newArrayDeclarator : (LBRACK expression? RBRACK)+ ;
STAR : "*" ;
DIV : "/" ;
MOD : "%" ;
SL : "<<" ;
LE : "<=" ;
GE : ">=" ;
NOT_EQUAL : "!=" ;
EQUAL : "==" ;
BXOR : "^" ;
BOR : "|" ;
LAND : "&&" ;
LOR : "||" ;
annotationMemberArrayInitializer : LCURLY (annotationMemberValue (COMMA annotationMemberValue)*)? COMMA? RCURLY ;
importDefinition : "import" "static"? identifierStar SEMI ;
identifierStar : IDENT (DOT IDENT)* (DOT STAR)? ;
typeDefinition : modifiers (classDefinition | enumDefinition | interfaceDefinition | annotationTypeDefinition) | SEMI ;
