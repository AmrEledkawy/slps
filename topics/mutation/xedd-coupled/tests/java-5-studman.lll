compilationUnit : (packageDefinition | EPSILON) importDefinition* typeDefinition* ;
packageDefinition : annotations "package" identifier SEMI ;
annotations : annotation* ;
annotation : AT identifier (LPAREN annotationArguments? RPAREN)? ;
AT : "@" ;
identifier : IDENT (DOT IDENT)* ;
IDENT : ("a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" | "_" | "$") ("a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" | "_" | "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "$")* ;
DOT : "." ;
LPAREN : "(" ;
annotationArguments : annotationMemberValueInitializer | anntotationMemberValuePairs ;
annotationMemberValueInitializer : conditionalExpression | annotation | annotationMemberArrayInitializer ;
conditionalExpression : logicalOrExpression (QUESTION assignmentExpression COLON conditionalExpression)? ;
logicalOrExpression : logicalAndExpression (LOR logicalAndExpression)* ;
logicalAndExpression : inclusiveOrExpression (LAND inclusiveOrExpression)* ;
inclusiveOrExpression : exclusiveOrExpression (BOR exclusiveOrExpression)* ;
exclusiveOrExpression : andExpression (BXOR andExpression)* ;
andExpression : equalityExpression (BAND equalityExpression)* ;
equalityExpression : relationalExpression ((NOT_EQUAL | EQUAL) relationalExpression)* ;
relationalExpression : shiftExpression (((LT | GT | LE | GE) shiftExpression)* | ("instanceof" typeSpec)) ;
shiftExpression : additiveExpression ((SL | SR | BSR) additiveExpression)* ;
additiveExpression : multiplicativeExpression ((PLUS | MINUS) multiplicativeExpression)* ;
multiplicativeExpression : unaryExpression ((STAR | DIV | MOD) unaryExpression)* ;
unaryExpression : INC unaryExpression | DEC unaryExpression | MINUS unaryExpression | PLUS unaryExpression | unaryExpressionNotPlusMinus ;
INC : "++" ;
DEC : "--" ;
MINUS : "-" ;
PLUS : "+" ;
unaryExpressionNotPlusMinus : BNOT unaryExpression | LNOT unaryExpression | LPAREN builtInTypeSpec RPAREN unaryExpression | LPAREN classTypeSpec RPAREN unaryExpressionNotPlusMinus | postfixExpression ;
BNOT : "~" ;
LNOT : "!" ;
builtInTypeSpec : builtInType (LBRACK RBRACK)* ;
builtInType : "void" | "boolean" | "byte" | "char" | "short" | "int" | "float" | "long" | "double" ;
LBRACK : "[" ;
RBRACK : "]" ;
RPAREN : ")" ;
classTypeSpec : classOrInterfaceType (LBRACK RBRACK)* ;
classOrInterfaceType : IDENT typeArguments? (DOT IDENT typeArguments?)* ;
typeArguments : LT typeArgument (COMMA typeArgument)* typeArgumentsOrParametersEnd? ;
LT : "<" ;
typeArgument : typeArgumentSpec | wildcardType ;
typeArgumentSpec : classTypeSpec | builtInTypeArraySpec ;
builtInTypeArraySpec : builtInType (LBRACK RBRACK)+ ;
wildcardType : QUESTION typeArgumentBounds? ;
QUESTION : "?" ;
typeArgumentBounds : ("extends" | "super") classOrInterfaceType ;
COMMA : "," ;
typeArgumentsOrParametersEnd : GT | SR | BSR ;
GT : ">" ;
SR : ">>" ;
BSR : ">>>" ;
postfixExpression : primaryExpression ((DOT typeArguments? ((IDENT (LPAREN argList RPAREN)?) | ("super" ((LPAREN argList RPAREN) | (DOT typeArguments? IDENT (LPAREN argList RPAREN)?))))) | (DOT "this") | (DOT newExpression) | (LBRACK expression RBRACK))* (INC | DEC)? ;
primaryExpression : identPrimary (DOT "class")? | constant | "true" | "false" | "null" | newExpression | "this" | "super" | LPAREN assignmentExpression RPAREN | builtInType (LBRACK RBRACK)* DOT "class" ;
identPrimary : typeArguments? IDENT ((DOT typeArguments? IDENT) | EPSILON)* ((LPAREN argList RPAREN) | (LBRACK RBRACK)+)? ;
argList : expressionList | EPSILON ;
expressionList : expression (COMMA expression)* ;
expression : assignmentExpression ;
assignmentExpression : conditionalExpression ((ASSIGN | PLUS_ASSIGN | MINUS_ASSIGN | STAR_ASSIGN | DIV_ASSIGN | MOD_ASSIGN | SR_ASSIGN | BSR_ASSIGN | SL_ASSIGN | BAND_ASSIGN | BXOR_ASSIGN | BOR_ASSIGN) assignmentExpression)? ;
ASSIGN : "=" ;
PLUS_ASSIGN : "+=" ;
MINUS_ASSIGN : "-=" ;
STAR_ASSIGN : "*=" ;
DIV_ASSIGN : "/=" ;
MOD_ASSIGN : "%=" ;
SR_ASSIGN : ">>=" ;
BSR_ASSIGN : ">>>=" ;
SL_ASSIGN : "<<=" ;
BAND_ASSIGN : "&=" ;
BXOR_ASSIGN : "^=" ;
BOR_ASSIGN : "|=" ;
constant : NUM_INT | CHAR_LITERAL | STRING_LITERAL | NUM_FLOAT | NUM_LONG | NUM_DOUBLE ;
NUM_INT : "." ((("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ EXPONENT? FLOAT_SUFFIX?) | "..")? | (("0" ((("x" | "X") HEX_DIGIT+) | ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ | ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7")+)?) | (("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9") ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")*)) ("l" | "L" | ("." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* EXPONENT? FLOAT_SUFFIX?) | (EXPONENT FLOAT_SUFFIX?) | FLOAT_SUFFIX)? ;
EXPONENT : ("e" | "E") ("+" | "-")? ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ;
FLOAT_SUFFIX : "f" | "F" | "d" | "D" ;
HEX_DIGIT : "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "A" | "B" | "C" | "D" | "E" | "F" | "a" | "b" | "c" | "d" | "e" | "f" ;
CHAR_LITERAL : "\'" (ESC | STR) "\'" ;
ESC : "\\" ("n" | "r" | "t" | "b" | "f" | QUOTES3 | "\'" | "\\" | ("u"+ HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT) | (("0" | "1" | "2" | "3") (("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7") ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7")?)?) | (("4" | "5" | "6" | "7") ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7")?)) ;
STRING_LITERAL : QUOTES3 (ESC | STR)* QUOTES3 ;
NUM_FLOAT : "." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ EXPONENT? ("f" | "F") | "0" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ("." | EXPONENT | "f" | "F") | ("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* ((("." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")*)? EXPONENT? ("f" | "F")) | EXPONENT) ;
NUM_LONG : ("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* ("l" | "L") ;
NUM_DOUBLE : "." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ EXPONENT? ("d" | "D") | "0" ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ("." | EXPONENT | "d" | "D") | ("1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")+ ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")* ((("." ("0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9")*)? EXPONENT? ("d" | "D")) | EXPONENT) ;
newExpression : "new" typeArguments? type ((LPAREN argList RPAREN classBlock?) | (newArrayDeclarator arrayInitializer?)) ;
type : classOrInterfaceType | builtInType ;
classBlock : LCURLY (classField | SEMI)* RCURLY ;
LCURLY : "{" ;
classField : modifiers (typeDefinitionInternal | (typeParameters? ((ctorHead constructorBody) | (typeSpec ((IDENT LPAREN parameterDeclarationList RPAREN declaratorBrackets throwsClause? (compoundStatement | SEMI)) | (variableDefinitions SEMI)))))) | "static" compoundStatement | compoundStatement ;
modifiers : (modifier | annotation)* ;
modifier : "private" | "public" | "protected" | "static" | "transient" | "final" | "abstract" | "native" | "threadsafe" | "synchronized" | "volatile" | "strictfp" ;
typeDefinitionInternal : classDefinition | interfaceDefinition | enumDefinition | annotationDefinition ;
classDefinition : "class" IDENT typeParameters? superClassClause implementsClause classBlock ;
typeParameters : LT typeParameter (COMMA typeParameter)* typeArgumentsOrParametersEnd? ;
typeParameter : IDENT typeParameterBounds? ;
typeParameterBounds : "extends" classOrInterfaceType (BAND classOrInterfaceType)* ;
BAND : "&" ;
superClassClause : ("extends" classOrInterfaceType)? ;
implementsClause : ("implements" classOrInterfaceType (COMMA classOrInterfaceType)*)? ;
interfaceDefinition : "interface" IDENT typeParameters? interfaceExtends interfaceBlock ;
interfaceExtends : ("extends" classOrInterfaceType (COMMA classOrInterfaceType)*)? ;
interfaceBlock : LCURLY (interfaceField | SEMI)* RCURLY ;
interfaceField : modifiers (typeDefinitionInternal | (typeParameters? typeSpec ((IDENT LPAREN parameterDeclarationList RPAREN declaratorBrackets throwsClause? SEMI) | (variableDefinitions SEMI)))) ;
typeSpec : classTypeSpec | builtInTypeSpec ;
parameterDeclarationList : ((parameterDeclaration (COMMA parameterDeclaration)* (COMMA variableLengthParameterDeclaration)?) | variableLengthParameterDeclaration)? ;
parameterDeclaration : parameterModifier typeSpec IDENT declaratorBrackets ;
parameterModifier : annotation* "final"? annotation* ;
declaratorBrackets : (LBRACK RBRACK)* ;
variableLengthParameterDeclaration : parameterModifier typeSpec TRIPLE_DOT IDENT declaratorBrackets ;
TRIPLE_DOT : "..." ;
throwsClause : "throws" identifier (COMMA identifier)* ;
SEMI : ";" ;
variableDefinitions : variableDeclarator (COMMA variableDeclarator)* ;
variableDeclarator : IDENT declaratorBrackets varInitializer ;
varInitializer : (ASSIGN initializer)? ;
initializer : expression | arrayInitializer ;
arrayInitializer : LCURLY (initializer (COMMA initializer)* COMMA?)? RCURLY ;
RCURLY : "}" ;
enumDefinition : "enum" IDENT implementsClause enumBlock ;
enumBlock : LCURLY (enumConstant (COMMA enumConstant)* COMMA?)? (SEMI (classField | SEMI)*)? RCURLY ;
enumConstant : annotations IDENT (LPAREN argList RPAREN)? enumConstantBlock? ;
enumConstantBlock : LCURLY (enumConstantField | SEMI)* RCURLY ;
enumConstantField : modifiers (typeDefinitionInternal | (typeParameters? typeSpec ((IDENT LPAREN parameterDeclarationList RPAREN declaratorBrackets throwsClause? (compoundStatement | SEMI)) | (variableDefinitions SEMI)))) | compoundStatement ;
compoundStatement : LCURLY statement* RCURLY ;
statement : compoundStatement | declaration SEMI | expression SEMI | modifiers classDefinition | IDENT COLON statement | "if" LPAREN expression RPAREN statement ("else" statement)? | forStatement | "while" LPAREN expression RPAREN statement | "do" statement "while" LPAREN expression RPAREN SEMI | "break" IDENT? SEMI | "continue" IDENT? SEMI | "return" expression? SEMI | "switch" LPAREN expression RPAREN LCURLY casesGroup* RCURLY | tryBlock | "throw" expression SEMI | "synchronized" LPAREN expression RPAREN compoundStatement | "assert" expression (COLON expression)? SEMI | SEMI ;
declaration : modifiers typeSpec variableDefinitions ;
COLON : ":" ;
forStatement : "for" LPAREN (traditionalForClause | forEachClause) RPAREN statement ;
traditionalForClause : forInit SEMI forCond SEMI forIter ;
forInit : (declaration | expressionList)? ;
forCond : expression? ;
forIter : expressionList? ;
forEachClause : parameterDeclaration COLON expression ;
casesGroup : aCase+ caseSList ;
aCase : (("case" expression) | "default") COLON ;
caseSList : statement* ;
tryBlock : "try" compoundStatement handler* finallyClause? ;
handler : "catch" LPAREN parameterDeclaration RPAREN compoundStatement ;
finallyClause : "finally" compoundStatement ;
annotationDefinition : AT "interface" IDENT annotationBlock ;
annotationBlock : LCURLY (annotationField | SEMI)* RCURLY ;
annotationField : modifiers (typeDefinitionInternal | (typeSpec ((IDENT LPAREN RPAREN declaratorBrackets ("default" annotationMemberValueInitializer)? SEMI) | (variableDefinitions SEMI)))) ;
ctorHead : IDENT LPAREN parameterDeclarationList RPAREN throwsClause? ;
constructorBody : LCURLY explicitConstructorInvocation? statement* RCURLY ;
explicitConstructorInvocation : typeArguments? (("this" LPAREN argList RPAREN SEMI) | ("super" LPAREN argList RPAREN SEMI)) ;
newArrayDeclarator : (LBRACK expression? RBRACK)+ ;
STAR : "*" ;
DIV : "/" ;
MOD : "%" ;
SL : "<<" ;
LE : "<=" ;
GE : ">=" ;
NOT_EQUAL : "!=" ;
EQUAL : "==" ;
BXOR : "^" ;
BOR : "|" ;
LAND : "&&" ;
LOR : "||" ;
annotationMemberArrayInitializer : LCURLY (annotationMemberArrayValueInitializer (COMMA annotationMemberArrayValueInitializer)* COMMA?)? RCURLY ;
annotationMemberArrayValueInitializer : conditionalExpression | annotation ;
anntotationMemberValuePairs : annotationMemberValuePair (COMMA annotationMemberValuePair)* ;
annotationMemberValuePair : IDENT ASSIGN annotationMemberValueInitializer ;
importDefinition : "import" "static"? identifierStar SEMI ;
identifierStar : IDENT (DOT IDENT)* (DOT STAR)? ;
typeDefinition : modifiers typeDefinitionInternal | SEMI ;
