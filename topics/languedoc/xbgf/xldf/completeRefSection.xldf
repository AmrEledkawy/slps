<?xml version="1.0" encoding="utf-8"?>
<xldf:evolution-sequence
  xmlns:mml="http://www.w3.org/1998/Math/MathML"
  xmlns:bgf="http://planet-sl.org/bgf"
  xmlns:xbgf="http://planet-sl.org/xbgf"
  xmlns:xldf="http://planet-sl.org/xldf"
  xmlns:ldf="http://planet-sl.org/ldf">

  <!-- compose a section on refactoring transformations -->
  <xldf:retitle>
    <from>
      <title>refactoring-transformation</title>
    </from>
    <to>Other refactoring transformations</to>
  </xldf:retitle>
  <xldf:place>
    <section>massage</section>
    <inside>refactoring-transformation</inside>
  </xldf:place>

  <xldf:append>
    <where>massage</where>
    <content>
      <text>
        The massage relation is defined as follows. First of all, a choice of any two
        symbols with EBNF modifiers can be refactored to a single modifier according to
        the table below (parenthesized expressions are not implemented directly, but
        covered by other variants):
      </text>
      <table>
        <header>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:mo>|</mml:mo>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:varepsilon/>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                    <mml:mi>x</mml:mi>
                    <mml:mo>?</mml:mo>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>+</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
        </header>
        <row>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:varepsilon/>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mfenced>
                  <mml:varepsilon/>
                </mml:mfenced>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                    <mml:mi>x</mml:mi>
                    <mml:mo>?</mml:mo>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                    <mml:mi>x</mml:mi>
                    <mml:mo>?</mml:mo>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
        </row>
        <row>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                    <mml:mi>x</mml:mi>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                    <mml:mi>x</mml:mi>
                    <mml:mo>?</mml:mo>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                    <mml:mi>x</mml:mi>
                    <mml:mo>?</mml:mo>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>+</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
        </row>
        <row>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                    <mml:mi>x</mml:mi>
                    <mml:mo>?</mml:mo>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                    <mml:mi>x</mml:mi>
                    <mml:mo>?</mml:mo>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                    <mml:mi>x</mml:mi>
                    <mml:mo>?</mml:mo>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mfenced>
                    <mml:mi>x</mml:mi>
                    <mml:mo>?</mml:mo>
                </mml:mfenced>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
        </row>
        <row>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>+</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>+</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mfenced>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>+</mml:mo>
                  </mml:msup>
                </mml:mfenced>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
        </row>
        <row>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mfenced>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mfenced>
              </mml:math>
            </formula>
          </cell>
        </row>
      </table>
      <text>
        Second, a composition of two EBNF modifers can be massaged to one modifier according
        to the table below:
      </text>
      <table>
        <header>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:mi>y</mml:mi>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                    <mml:mi>y</mml:mi>
                    <mml:mo>?</mml:mo>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>y</mml:mi>
                    <mml:mo>+</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>y</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
        </header>
        <row>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                  <mml:mo>?</mml:mo>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                  <mml:mo>?</mml:mo>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
        </row>
        <row>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>+</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>+</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
        </row>
        <row>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
        </row>
      </table>
      <text>
        Sequential composition of symbols is more complicated since
        it does not necessarily yield an EBNF modifier (those modifiers
        are not expressive enough to denote ``one or two'' repetitions,
        ``two or more'', etc). The following table shows the possible
        <ldf:keyword>massage</ldf:keyword> manipulations:
      </text>
      <table>
        <header>
          <cell>
            <empty/>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                  <mml:mo>?</mml:mo>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>+</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
        </header>
        <row>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <empty/>
          </cell>
          <cell>
            <empty/>
          </cell>
          <cell>
            <empty/>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>+</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
        </row>
        <row>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:mi>x</mml:mi>
                  <mml:mo>?</mml:mo>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <empty/>
          </cell>
          <cell>
            <empty/>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>+</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
        </row>
        <row>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>+</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <empty/>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>+</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <empty/>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>+</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
        </row>
        <row>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>+</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>+</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
          <cell>
            <formula>
              <mml:math>
                <mml:mrow>
                  <mml:msup>
                    <mml:mi>x</mml:mi>
                    <mml:mo>*</mml:mo>
                  </mml:msup>
                </mml:mrow>
              </mml:math>
            </formula>
          </cell>
        </row>
      </table>
      <text>
        Associativity rules for <ldf:keyword>massage</ldf:keyword>:
      </text>
      <formula>
        <!--x (yx)? = (xy)? x-->
        <mml:math>
          <mml:mrow>
            <mml:mrow>
              <mml:mi>x</mml:mi>
              <mml:mfenced>
                <mml:mi>y</mml:mi>
                <mml:mi>x</mml:mi>
              </mml:mfenced>
              <mml:mo>?</mml:mo>
            </mml:mrow>
            <mml:mo>=</mml:mo>
            <mml:mrow>
              <mml:mfenced>
                <mml:mi>x</mml:mi>
                <mml:mi>y</mml:mi>
              </mml:mfenced>
              <mml:mo>?</mml:mo>
              <mml:mi>x</mml:mi>
            </mml:mrow>
          </mml:mrow>
        </mml:math>
      </formula>
      <formula>
        <!--x (yx)^+ = (xy)^+ x-->
        <mml:math>
          <mml:mrow>
            <mml:mrow>
              <mml:mi>x</mml:mi>
              <mml:msup>
                <mml:mfenced>
                  <mml:mi>y</mml:mi>
                  <mml:mi>x</mml:mi>
                </mml:mfenced>
                <mml:mo>+</mml:mo>
              </mml:msup>
            </mml:mrow>
            <mml:mo>=</mml:mo>
            <mml:mrow>
              <mml:msup>
                <mml:mfenced>
                  <mml:mi>x</mml:mi>
                  <mml:mi>y</mml:mi>
                </mml:mfenced>
                <mml:mo>+</mml:mo>
              </mml:msup>
              <mml:mi>x</mml:mi>
            </mml:mrow>
          </mml:mrow>
        </mml:math>
      </formula>
      <formula>
        <!--x (yx)^\star = (xy)^\star x-->
        <mml:math>
        <mml:mrow>
          <mml:mrow>
            <mml:mi>x</mml:mi>
            <mml:msup>
              <mml:mfenced>
                <mml:mi>y</mml:mi>
                <mml:mi>x</mml:mi>
              </mml:mfenced>
              <mml:mo>*</mml:mo>
            </mml:msup>
          </mml:mrow>
          <mml:mo>=</mml:mo>
          <mml:mrow>
            <mml:msup>
              <mml:mfenced>
                <mml:mi>x</mml:mi>
                <mml:mi>y</mml:mi>
              </mml:mfenced>
              <mml:mo>*</mml:mo>
            </mml:msup>
            <mml:mi>x</mml:mi>
          </mml:mrow>
        </mml:mrow>
      </mml:math>
    </formula>
    </content>
  </xldf:append>
  <xldf:add-subsection>
    <example id="massage-example">
      <content>
        <text>
          Distributivity rules for optionality modifier such as these:
        </text>
        <formula>
          <!--(x? y?)? = x? y?-->
          <mml:math>
            <mml:mrow>
              <mml:mfenced>
                <mml:mi>x</mml:mi>
                <mml:mo>?</mml:mo>
                <mml:mi>y</mml:mi>
                <mml:mo>?</mml:mo>
              </mml:mfenced>
              <mml:mo>?</mml:mo>
            </mml:mrow>
            <mml:mo>=</mml:mo>
            <mml:mrow>
              <mml:mi>x</mml:mi>
              <mml:mo>?</mml:mo>
              <mml:mi>y</mml:mi>
              <mml:mo>?</mml:mo>
            </mml:mrow>
          </mml:math>
        </formula>
        <formula>
          <!--(x^\star y?)? = x^\star y?-->
          <mml:math>
            <mml:mrow>
              <mml:mfenced>
                <mml:msup>
                  <mml:mi>x</mml:mi>
                  <mml:mo>*</mml:mo>
                </mml:msup>
                <mml:mi>y</mml:mi>
                <mml:mo>?</mml:mo>
              </mml:mfenced>
              <mml:mo>?</mml:mo>
            </mml:mrow>
            <mml:mo>=</mml:mo>
            <mml:mrow>
              <mml:msup>
                <mml:mi>x</mml:mi>
                <mml:mo>*</mml:mo>
              </mml:msup>
              <mml:mi>y</mml:mi>
              <mml:mo>?</mml:mo>
            </mml:mrow>
          </mml:math>
        </formula>
        <formula>
          <!--(x? y^\star)? = x? y^\star-->
          <mml:math>
            <mml:mrow>
              <mml:mfenced>
                 <mml:mi>x</mml:mi>
                <mml:mo>?</mml:mo>
              <mml:msup>
                  <mml:mi>y</mml:mi>
                  <mml:mo>*</mml:mo>
                </mml:msup>
               </mml:mfenced>
              <mml:mo>?</mml:mo>
            </mml:mrow>
            <mml:mo>=</mml:mo>
            <mml:mrow>
              <mml:mi>x</mml:mi>
              <mml:mo>?</mml:mo>
              <mml:msup>
                <mml:mi>y</mml:mi>
                <mml:mo>*</mml:mo>
              </mml:msup>
            </mml:mrow>
          </mml:math>
        </formula>
        <formula>
          <!--(x^\star y^\star)? = x^\star y^\star-->
          <mml:math>
            <mml:mrow>
              <mml:mfenced>
                <mml:msup>
                  <mml:mi>x</mml:mi>
                  <mml:mo>*</mml:mo>
                </mml:msup>
                <mml:msup>
                  <mml:mi>y</mml:mi>
                  <mml:mo>*</mml:mo>
                </mml:msup>
              </mml:mfenced>
              <mml:mo>?</mml:mo>
            </mml:mrow>
            <mml:mo>=</mml:mo>
            <mml:mrow>
              <mml:msup>
                <mml:mi>x</mml:mi>
                <mml:mo>*</mml:mo>
              </mml:msup>
              <mml:msup>
                <mml:mi>y</mml:mi>
                <mml:mo>*</mml:mo>
              </mml:msup>
            </mml:mrow>
          </mml:math>
        </formula>
        <formula>
          <!--(x | y)? = x? | y?-->
          <mml:math>
            <mml:mrow>
              <mml:mfenced>
                  <mml:mi>x</mml:mi>
                  <mml:mo>|</mml:mo>
                  <mml:mi>y</mml:mi>
              </mml:mfenced>
              <mml:mo>?</mml:mo>
            </mml:mrow>
            <mml:mo>=</mml:mo>
            <mml:mrow>
              <mml:mrow>
                <mml:mi>x</mml:mi>
                <mml:mo>?</mml:mo>
              </mml:mrow>
              <mml:mo>|</mml:mo>
              <mml:mrow>
                <mml:mi>y</mml:mi>
                <mml:mo>?</mml:mo>
              </mml:mrow>
            </mml:mrow>
          </mml:math>
        </formula>
        <text>
          are not explicitly covered by <ldf:keyword>massage</ldf:keyword> since it is
          possible to emulate them with a sequence of abovementioned patterns of
          <ldf:keyword>massage</ldf:keyword>, as well as with <ldf:keyword>factor</ldf:keyword>
          and similar transformations. Let us take the last formula as an example of a massaging
          that takes several to complete.
          The input BGF is:
        </text>
      </content>
    </example>
    <to>massage</to>
  </xldf:add-subsection>
  <xldf:import-grammar>
    <target>massage-example</target>
    <file>../../transformation/xbgf/tests/massage_distr_ch.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>massage-example</where>
    <content>
      <text>After performing these transformation steps:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>massage-example</target>
    <file>../../transformation/xbgf/tests/massage_distr_ch.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>massage-example</where>
    <content>
      <text>The result will be:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>massage-example</target>
    <file>../../transformation/xbgf/tests/massage_distr_ch.baseline</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>massage-example</where>
    <content>
      <text>
        The selectors and <ldf:keyword>anonymize</ldf:keyword> commands are necessary
        because otherwise the choice of two epsilons would be removed automatically
        during the normalisation phase. The rest of distributivity laws are expressed
        quite similarly to this example.
      </text>
    </content>
  </xldf:append>

  <xldf:place>
    <section>distribute</section>
    <inside>refactoring-transformation</inside>
  </xldf:place>
  <xldf:add-subsection>
    <semantics>
      <content>
        <text>
          In fact, <ldf:keyword>distribute</ldf:keyword> is nothing more than an automated
          version of <ldf:keyword>factor</ldf:keyword> that agressively pushes all the choices
          that can be found in a production outwards.
        </text>
        <text>
          This transformation is apparently non-injective, hence, it is impossible to have
          a complete inverse of it. A more general <ldf:keyword>factor</ldf:keyword>
          transformation, however, is as capable of emulating <ldf:keyword>distribute</ldf:keyword>'s
          effect as it is capable of doing the reverse thing.
        </text>
      </content>
    </semantics>
    <to>distribute</to>
  </xldf:add-subsection>
  <xldf:add-subsection>
    <example id="distribute-example">
      <content>
        <text>For instance,</text>
      </content>
    </example>
    <to>distribute</to>
  </xldf:add-subsection>
  <xldf:import-grammar>
    <target>distribute-example</target>
    <file>../../transformation/xbgf/tests/distribute_nt.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>distribute-example</where>
    <content>
      <text>After using this transformation:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>distribute-example</target>
    <file>../../transformation/xbgf/tests/distribute_nt.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>distribute-example</where>
    <content>
      <text>Will look like this:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>distribute-example</target>
    <file>../../transformation/xbgf/tests/distribute_nt.baseline</file>
  </xldf:import-grammar>

  <xldf:place>
    <section>factor</section>
    <inside>refactoring-transformation</inside>
  </xldf:place>
  <xldf:add-subsection>
    <semantics>
      <content>
        <text>
          Factor transformations tend to be quite frequently used in grammar convergence.
          They also have a tendency to be very long---since it is impossible to implement
          <ldf:keyword>factor</ldf:keyword> symmetrically to <ldf:keyword>distribute</ldf:keyword>
          (i.e., fully automated), the language engineer needs to supply two complete
          expressions. The transformer then can easily assert that they are related by
          distribution: basically, it internally performs <ldf:keyword>distribute</ldf:keyword>
          on both of them and expects them to become identical. Hence, it is possible
          to do ``incomplete'' factoring by pushing choices inwards but not to the innermost
          position.
        </text>
        <text>
          Two most commonly seen patterns of <ldf:keyword>factor</ldf:keyword> use are the following.
          First, it is applied when we have a choice of two long expressions that are almost
          identical except for some mismatching part. That part can be either extracted
          or massaged later with more transformations. Second, it is needed when we have a wide
          choice with the same leading (or trailing) symbol, and the goal is to let the common
          part stay and encapsulate the rest inside a different nonterminal (by following
          <ldf:keyword>extract</ldf:keyword>).
        </text>
      </content>
    </semantics>
    <to>factor</to>
  </xldf:add-subsection>
  <xldf:add-subsection>
    <example id="factor-example">
      <content>
        <text>For instance,</text>
      </content>
    </example>
    <to>factor</to>
  </xldf:add-subsection>
  <xldf:import-grammar>
    <target>factor-example</target>
    <file>../../transformation/xbgf/tests/factor_local.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>factor-example</where>
    <content>
      <text>After using this transformation (note the order of expressions):</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>factor-example</target>
    <file>../../transformation/xbgf/tests/factor_local.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>factor-example</where>
    <content>
      <text>Will look like this:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>factor-example</target>
    <file>../../transformation/xbgf/tests/factor_local.baseline</file>
  </xldf:import-grammar>

  <xldf:place>
    <section>deyaccify</section>
    <inside>refactoring-transformation</inside>
  </xldf:place>
  <xldf:append>
    <where>deyaccify</where>
    <content>
      <text>
        Deyaccification uses several general patterns. Left recursion like this:
      </text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>deyaccify</target>
    <file>../../transformation/xbgf/tests/deyaccify_left.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>deyaccify</where>
    <content>
      <text>
        Becomes:
      </text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>deyaccify</target>
    <file>../../transformation/xbgf/tests/deyaccify_left.baseline</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>deyaccify</where>
    <content>
      <text>
        Right recursion like this:
      </text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>deyaccify</target>
    <file>../../transformation/xbgf/tests/deyaccify_right.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>deyaccify</where>
    <content>
      <text>
        Becomes:
      </text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>deyaccify</target>
    <file>../../transformation/xbgf/tests/deyaccify_right.baseline</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>deyaccify</where>
    <content>
      <text>
        In either case, it is checked if bar and wez are the same nonterminal.
        If they are, the result is more concise:
      </text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>deyaccify</target>
    <file>../../transformation/xbgf/tests/deyaccify_right_plus.baseline</file>
  </xldf:import-grammar>

  <xldf:place>
    <section>yaccify</section>
    <inside>refactoring-transformation</inside>
  </xldf:place>
  <xldf:add-subsection>
    <semantics>
      <content>
        <text>
          Yaccification is a typical example of grammar adaptation activity.
          However, it can be utilised in grammar convergence process as well:
          think of a situation when one of the sources is yaccified using left
          recursion while the other one---using right recursion. In such a case
          it would be better to deyaccify both of them. If this is due to some
          considerations impossible or undesirable, one can deyaccify, say,
          left recursion and then yaccify if back to right recursion.
        </text>
        <text>
          Since it is not possible for the transformation engine to guess which
          kind of BNF recursion the suite user would need, <ldf:keyword>yaccify</ldf:keyword>
          takes two productions as parameters, unlike <ldf:keyword>deyaccify</ldf:keyword>
          which works perfectly just given the nonterminal name.
        </text>
      </content>
    </semantics>
    <to>yaccify</to>
  </xldf:add-subsection>
  <xldf:add-subsection>
    <example id="yaccify-example">
      <content>
        <text>For instance, this piece of grammar:</text>
      </content>
    </example>
    <to>yaccify</to>
  </xldf:add-subsection>
  <xldf:import-grammar>
    <target>yaccify-example</target>
    <file>../../transformation/xbgf/tests/yaccify_left_plus.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>yaccify-example</where>
    <content>
      <text>can either be yaccified with left recursion:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>yaccify-example</target>
    <file>../../transformation/xbgf/tests/yaccify_left_plus.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>yaccify-example</where>
    <content>
      <text>to look like this:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>yaccify-example</target>
    <file>../../transformation/xbgf/tests/yaccify_left_plus.baseline</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>yaccify-example</where>
    <content>
      <text>or yaccified with right recursion:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>yaccify-example</target>
    <file>../../transformation/xbgf/tests/yaccify_right_plus.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>yaccify-example</where>
    <content>
      <text>to look like this:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>yaccify-example</target>
    <file>../../transformation/xbgf/tests/yaccify_right_plus.baseline</file>
  </xldf:import-grammar>

  <xldf:place>
    <section>eliminate</section>
    <inside>refactoring-transformation</inside>
  </xldf:place>
  <xldf:add-subsection>
    <example id="eliminate-example">
      <content>
        <text>For instance,</text>
      </content>
    </example>
    <to>eliminate</to>
  </xldf:add-subsection>
  <xldf:import-grammar>
    <target>eliminate-example</target>
    <file>../../transformation/xbgf/tests/eliminate.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>eliminate-example</where>
    <content>
      <text>After using this transformation:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>eliminate-example</target>
    <file>../../transformation/xbgf/tests/eliminate.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>eliminate-example</where>
    <content>
      <text>Will look like this:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>eliminate-example</target>
    <file>../../transformation/xbgf/tests/eliminate.baseline</file>
  </xldf:import-grammar>

  <xldf:place>
    <section>introduce</section>
    <inside>refactoring-transformation</inside>
  </xldf:place>
  <xldf:add-subsection>
    <example id="introduce-example">
      <content>
        <text>For instance,</text>
      </content>
    </example>
    <to>introduce</to>
  </xldf:add-subsection>
  <xldf:import-grammar>
    <target>introduce-example</target>
    <file>../../transformation/xbgf/tests/introduce.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>introduce-example</where>
    <content>
      <text>After using this transformation:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>introduce-example</target>
    <file>../../transformation/xbgf/tests/introduce.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>introduce-example</where>
    <content>
      <text>Will look like this:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>introduce-example</target>
    <file>../../transformation/xbgf/tests/introduce.baseline</file>
  </xldf:import-grammar>

  <xldf:place>
    <section>import</section>
    <inside>refactoring-transformation</inside>
  </xldf:place>
  <xldf:add-subsection>
    <semantics>
      <content>
        <text>
          There are times when <ldf:keyword>introduce</ldf:keyword> is just not enough.
          The simplest of such a situations is a case when we want to introduce two
          productions, each defining a fresh nonterminal symbol, and each using the other.
          Without <ldf:keyword>import</ldf:keyword> the only way to do it was to run one
          <ldf:keyword>introduce</ldf:keyword> and one <ldf:keyword>define</ldf:keyword>,
          which is semantically wrong since we are sure that before the first nonterminal
          is introduced, the second one was fresh. So, instead we take the interdependent
          productions together and introduce them in one step.
        </text>
        <text>
          Technically, <ldf:keyword>import</ldf:keyword> can be used any time to
          substitute any number of <ldf:keyword>introduce</ldf:keyword> transformations.
        </text>
      </content>
    </semantics>
    <to>import</to>
  </xldf:add-subsection>
  <xldf:add-subsection>
    <example id="import-example">
      <content>
        <text>For instance,</text>
      </content>
    </example>
    <to>import</to>
  </xldf:add-subsection>
  <xldf:import-grammar>
    <target>import-example</target>
    <file>../../transformation/xbgf/tests/import.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>import-example</where>
    <content>
      <text>After using this transformation:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>import-example</target>
    <file>../../transformation/xbgf/tests/import.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>import-example</where>
    <content>
      <text>It will look like this:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>import-example</target>
    <file>../../transformation/xbgf/tests/import.baseline</file>
  </xldf:import-grammar>

  <xldf:place>
    <section>vertical</section>
    <inside>refactoring-transformation</inside>
  </xldf:place>
  <xldf:add-subsection>
    <example id="vertical-example">
      <content>
        <text>If the original production contained selectors:</text>
      </content>
    </example>
    <to>vertical</to>
  </xldf:add-subsection>
  <xldf:import-grammar>
    <target>vertical-example</target>
    <file>../../transformation/xbgf/tests/vertical_s.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>vertical-example</where>
    <content>
      <text>then, after using this transformation:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>vertical-example</target>
    <file>../../transformation/xbgf/tests/vertical_s.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>vertical-example</where>
    <content>
      <text>they are converted to labels:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>vertical-example</target>
    <file>../../transformation/xbgf/tests/vertical_s.baseline</file>
  </xldf:import-grammar>

  <xldf:place>
    <section>horizontal</section>
    <inside>refactoring-transformation</inside>
  </xldf:place>
  <xldf:add-subsection>
    <example id="horizontal-example">
      <content>
        <text>If some or all of the original productions are labelled:</text>
      </content>
    </example>
    <to>horizontal</to>
  </xldf:add-subsection>
  <xldf:import-grammar>
    <target>horizontal-example</target>
    <file>../../transformation/xbgf/tests/horizontal_l.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>horizontal-example</where>
    <content>
      <text>the, after using this transformation:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>horizontal-example</target>
    <file>../../transformation/xbgf/tests/horizontal_l.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>horizontal-example</where>
    <content>
      <text>each label is converted to a selector in a corresponding place:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>horizontal-example</target>
    <file>../../transformation/xbgf/tests/horizontal_l.baseline</file>
  </xldf:import-grammar>

  <xldf:place>
    <section>rassoc</section>
    <inside>refactoring-transformation</inside>
  </xldf:place>
  <xldf:add-subsection>
    <example id="rassoc-example">
      <content>
        <text>For instance,</text>
      </content>
    </example>
    <to>rassoc</to>
  </xldf:add-subsection>
  <xldf:import-grammar>
    <target>rassoc-example</target>
    <file>../../transformation/xbgf/tests/rassoc_s.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>rassoc-example</where>
    <content>
      <text>After using this transformation:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>rassoc-example</target>
    <file>../../transformation/xbgf/tests/rassoc_s.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>rassoc-example</where>
    <content>
      <text>Will look like this:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>rassoc-example</target>
    <file>../../transformation/xbgf/tests/rassoc_s.baseline</file>
  </xldf:import-grammar>
  
  <xldf:place>
    <section>lassoc</section>
    <inside>refactoring-transformation</inside>
  </xldf:place>
  <xldf:add-subsection>
    <example id="lassoc-example">
      <content>
        <text>For instance,</text>
      </content>
    </example>
    <to>lassoc</to>
  </xldf:add-subsection>
  <xldf:import-grammar>
    <target>lassoc-example</target>
    <file>../../transformation/xbgf/tests/lassoc_p.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>lassoc-example</where>
    <content>
      <text>After using this transformation:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>lassoc-example</target>
    <file>../../transformation/xbgf/tests/lassoc_p.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>lassoc-example</where>
    <content>
      <text>Will look like this:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>lassoc-example</target>
    <file>../../transformation/xbgf/tests/lassoc_p.baseline</file>
  </xldf:import-grammar>

  <xldf:change-role>
    <scope>refactoring-transformation</scope>
    <from>syntax</from>
    <to>synopsis</to>
  </xldf:change-role>

</xldf:evolution-sequence>
