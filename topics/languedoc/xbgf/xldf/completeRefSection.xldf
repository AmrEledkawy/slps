<?xml version="1.0" encoding="utf-8"?>
<xldf:sequence
  xmlns:bgf="http://planet-sl.org/bgf"
  xmlns:xbgf="http://planet-sl.org/xbgf"
  xmlns:xldf="http://planet-sl.org/xldf"
  xmlns:ldf="http://planet-sl.org/ldf">

  <!-- compose a section on refactoring transformations -->
  <xldf:rename>
    <from>
      <title>refactoring-transformation</title>
    </from>
    <to>Other refactoring transformations</to>
  </xldf:rename>
  <xldf:place>
    <section>element-massage</section>
    <inside>group-refactoring-transformation</inside>
  </xldf:place>

  <xldf:append>
    <where>element-massage</where>
    <content>
      <text>
        The massage relation is defined as follows. First of all, a choice of any two
        symbols with EBNF modifiers can be refactored to a single modifier according to
        the table below (parenthesized expressions are not implemented directly, but
        covered by other variants):
      </text>
      <table>
        <header>
          <cell>
            <formula>|</formula>
          </cell>
          <cell>
            <formula>\varepsilon</formula>
          </cell>
          <cell>
            <formula>x</formula>
          </cell>
          <cell>
            <formula>x?</formula>
          </cell>
          <cell>
            <formula>x^+</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
        </header>
        <row>
          <cell>
            <formula>\varepsilon</formula>
          </cell>
          <cell>
            <formula>(\varepsilon)</formula>
          </cell>
          <cell>
            <formula>x?</formula>
          </cell>
          <cell>
            <formula>x?</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
        </row>
        <row>
          <cell>
            <formula>x</formula>
          </cell>
          <cell>
            <formula>x?</formula>
          </cell>
          <cell>
            <formula>x</formula>
          </cell>
          <cell>
            <formula>x?</formula>
          </cell>
          <cell>
            <formula>x^+</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
        </row>
        <row>
          <cell>
            <formula>x?</formula>
          </cell>
          <cell>
            <formula>x?</formula>
          </cell>
          <cell>
            <formula>x?</formula>
          </cell>
          <cell>
            <formula>(x?)</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
        </row>
        <row>
          <cell>
            <formula>x^+</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^+</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>(x^+)</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
        </row>
        <row>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>(x^\star)</formula>
          </cell>
        </row>
      </table>
      <text>
        Second, a composition of two EBNF modifers can be massaged to one modifier according
        to the table below:
      </text>
      <table>
        <header>
          <cell>
            <formula>y</formula>
          </cell>
          <cell>
            <formula>y?</formula>
          </cell>
          <cell>
            <formula>y^+</formula>
          </cell>
          <cell>
            <formula>y^\star</formula>
          </cell>
        </header>
        <row>
          <cell>
            <formula>x?</formula>
          </cell>
          <cell>
            <formula>x?</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
        </row>
        <row>
          <cell>
            <formula>x^+</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^+</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
        </row>
        <row>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
        </row>
      </table>
      <text>
        Sequential composition of symbols is more complicated since
        it does not necessarily yield an EBNF modifier (those modifiers
        are not expressive enough to denote `one or two' repetitions,
        `two or more', etc). The following table shows the possible
        <ldf:keyword>massage</ldf:keyword> manipulations:
      </text>
      <table>
        <header>
          <cell>
            <empty/>
          </cell>
          <cell>
            <formula>x</formula>
          </cell>
          <cell>
            <formula>x?</formula>
          </cell>
          <cell>
            <formula>x^+</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
        </header>
        <row>
          <cell>
            <formula>x</formula>
          </cell>
          <cell>
            <empty/>
          </cell>
          <cell>
            <empty/>
          </cell>
          <cell>
            <empty/>
          </cell>
          <cell>
            <formula>x^+</formula>
          </cell>
        </row>
        <row>
          <cell>
            <formula>x?</formula>
          </cell>
          <cell>
            <empty/>
          </cell>
          <cell>
            <empty/>
          </cell>
          <cell>
            <formula>x^+</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
        </row>
        <row>
          <cell>
            <formula>x^+</formula>
          </cell>
          <cell>
            <empty/>
          </cell>
          <cell>
            <formula>x^+</formula>
          </cell>
          <cell>
            <empty/>
          </cell>
          <cell>
            <formula>x^+</formula>
          </cell>
        </row>
        <row>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^+</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^+</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
        </row>
      </table>
      <text>
        Distributivity rules for optionality modifier are also covered
        by <ldf:keyword>massage</ldf:keyword>:
      </text>
      <formula>(x? y?)? = x? y?</formula>
      <formula>(x^\star y?)? = x^\star y?</formula>
      <formula>(x? y^\star)? = x? y^\star</formula>
      <formula>(x | y)? = x? | y?</formula>
      <text>
        Associativity rules for <ldf:keyword>massage</ldf:keyword>:
      </text>
      <formula>x (yx)? = (xy)? x</formula>
      <formula>x (yx)^+ = (xy)^+ x</formula>
      <formula>x (yx)^\star = (xy)^\star x</formula>
    </content>
  </xldf:append>
  <xldf:add-subsection>
    <example id="massage-example">
      <content>
        <text>
          An example of a massaging that takes three steps to complete is presented below.
          The input BGF is:
        </text>
      </content>
    </example>
    <to>element-massage</to>
  </xldf:add-subsection>
  <xldf:import-grammar>
    <target>massage-example</target>
    <file>../../transformation/xbgf/tests/massage_triple.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>massage-example</where>
    <content>
      <text>After performing these transformation steps:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>massage-example</target>
    <file>../../transformation/xbgf/tests/massage_triple.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>massage-example</where>
    <content>
      <text>The result will be:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>massage-example</target>
    <file>../../transformation/xbgf/tests/massage_triple.baseline</file>
  </xldf:import-grammar>

  <xldf:place>
    <section>element-distribute</section>
    <inside>group-refactoring-transformation</inside>
  </xldf:place>
  <xldf:add-subsection>
    <example id="distribute-example">
      <content> <text>For example,</text></content>
    </example>
    <to>element-distribute</to>
  </xldf:add-subsection>
  <xldf:import-grammar>
    <target>distribute-example</target>
    <file>../../transformation/xbgf/tests/distribute_nt.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>distribute-example</where>
    <content>
      <text>After using this transformation:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>distribute-example</target>
    <file>../../transformation/xbgf/tests/distribute_nt.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>distribute-example</where>
    <content>
      <text>Will look like this:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>distribute-example</target>
    <file>../../transformation/xbgf/tests/distribute_nt.baseline</file>
  </xldf:import-grammar>
  
  <xldf:place>
    <section>element-factor</section>
    <inside>group-refactoring-transformation</inside>
  </xldf:place>
  <xldf:place>
    <section>element-deyaccify</section>
    <inside>group-refactoring-transformation</inside>
  </xldf:place>
  <xldf:append>
    <where>element-deyaccify</where>
    <content>
      <text>
        Deyaccification uses several general patterns. Left recursion like this:
      </text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>element-deyaccify</target>
    <file>../../transformation/xbgf/tests/deyaccify_left.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>element-deyaccify</where>
    <content>
      <text>
        Becomes:
      </text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>element-deyaccify</target>
    <file>../../transformation/xbgf/tests/deyaccify_left.baseline</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>element-deyaccify</where>
    <content>
      <text>
        Right recursion like this:
      </text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>element-deyaccify</target>
    <file>../../transformation/xbgf/tests/deyaccify_right.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>element-deyaccify</where>
    <content>
      <text>
        Becomes:
      </text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>element-deyaccify</target>
    <file>../../transformation/xbgf/tests/deyaccify_right.baseline</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>element-deyaccify</where>
    <content>
      <text>
        In either case, it is checked if bar and wez are the same. If they are, the result is more concise:
      </text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>element-deyaccify</target>
    <file>../../transformation/xbgf/tests/deyaccify_right_plus.baseline</file>
  </xldf:import-grammar>

  <xldf:place>
    <section>element-yaccify</section>
    <inside>group-refactoring-transformation</inside>
  </xldf:place>
  <xldf:place>
    <section>element-eliminate</section>
    <inside>group-refactoring-transformation</inside>
  </xldf:place>
  <xldf:place>
    <section>element-introduce</section>
    <inside>group-refactoring-transformation</inside>
  </xldf:place>
  <xldf:place>
    <section>element-import</section>
    <inside>group-refactoring-transformation</inside>
  </xldf:place>
  <xldf:place>
    <section>element-vertical</section>
    <inside>group-refactoring-transformation</inside>
  </xldf:place>
  <xldf:place>
    <section>element-horizontal</section>
    <inside>group-refactoring-transformation</inside>
  </xldf:place>
  <xldf:place>
    <section>element-rename</section>
    <inside>group-refactoring-transformation</inside>
  </xldf:place>
  <xldf:place>
    <section>element-rassoc</section>
    <inside>group-refactoring-transformation</inside>
  </xldf:place>
  <xldf:place>
    <section>element-lassoc</section>
    <inside>group-refactoring-transformation</inside>
  </xldf:place>

</xldf:sequence>
