<?xml version="1.0" encoding="utf-8"?>
<xldf:evolution-sequence
  xmlns:bgf="http://planet-sl.org/bgf"
  xmlns:xbgf="http://planet-sl.org/xbgf"
  xmlns:xldf="http://planet-sl.org/xldf"
  xmlns:ldf="http://planet-sl.org/ldf">

  <!-- compose a section on refactoring transformations -->
  <xldf:retitle>
    <from>
      <title>refactoring-transformation</title>
    </from>
    <to>Other refactoring transformations</to>
  </xldf:retitle>
  <xldf:place>
    <section>element-massage</section>
    <inside>group-refactoring-transformation</inside>
  </xldf:place>

  <xldf:append>
    <where>element-massage</where>
    <content>
      <text>
        The massage relation is defined as follows. First of all, a choice of any two
        symbols with EBNF modifiers can be refactored to a single modifier according to
        the table below (parenthesized expressions are not implemented directly, but
        covered by other variants):
      </text>
      <table>
        <header>
          <cell>
            <formula>|</formula>
          </cell>
          <cell>
            <formula>\varepsilon</formula>
          </cell>
          <cell>
            <formula>x</formula>
          </cell>
          <cell>
            <formula>x?</formula>
          </cell>
          <cell>
            <formula>x^+</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
        </header>
        <row>
          <cell>
            <formula>\varepsilon</formula>
          </cell>
          <cell>
            <formula>(\varepsilon)</formula>
          </cell>
          <cell>
            <formula>x?</formula>
          </cell>
          <cell>
            <formula>x?</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
        </row>
        <row>
          <cell>
            <formula>x</formula>
          </cell>
          <cell>
            <formula>x?</formula>
          </cell>
          <cell>
            <formula>x</formula>
          </cell>
          <cell>
            <formula>x?</formula>
          </cell>
          <cell>
            <formula>x^+</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
        </row>
        <row>
          <cell>
            <formula>x?</formula>
          </cell>
          <cell>
            <formula>x?</formula>
          </cell>
          <cell>
            <formula>x?</formula>
          </cell>
          <cell>
            <formula>(x?)</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
        </row>
        <row>
          <cell>
            <formula>x^+</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^+</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>(x^+)</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
        </row>
        <row>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>(x^\star)</formula>
          </cell>
        </row>
      </table>
      <text>
        Second, a composition of two EBNF modifers can be massaged to one modifier according
        to the table below:
      </text>
      <table>
        <header>
          <cell>
            <formula>y</formula>
          </cell>
          <cell>
            <formula>y?</formula>
          </cell>
          <cell>
            <formula>y^+</formula>
          </cell>
          <cell>
            <formula>y^\star</formula>
          </cell>
        </header>
        <row>
          <cell>
            <formula>x?</formula>
          </cell>
          <cell>
            <formula>x?</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
        </row>
        <row>
          <cell>
            <formula>x^+</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^+</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
        </row>
        <row>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
        </row>
      </table>
      <text>
        Sequential composition of symbols is more complicated since
        it does not necessarily yield an EBNF modifier (those modifiers
        are not expressive enough to denote `one or two' repetitions,
        `two or more', etc). The following table shows the possible
        <ldf:keyword>massage</ldf:keyword> manipulations:
      </text>
      <table>
        <header>
          <cell>
            <empty/>
          </cell>
          <cell>
            <formula>x</formula>
          </cell>
          <cell>
            <formula>x?</formula>
          </cell>
          <cell>
            <formula>x^+</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
        </header>
        <row>
          <cell>
            <formula>x</formula>
          </cell>
          <cell>
            <empty/>
          </cell>
          <cell>
            <empty/>
          </cell>
          <cell>
            <empty/>
          </cell>
          <cell>
            <formula>x^+</formula>
          </cell>
        </row>
        <row>
          <cell>
            <formula>x?</formula>
          </cell>
          <cell>
            <empty/>
          </cell>
          <cell>
            <empty/>
          </cell>
          <cell>
            <formula>x^+</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
        </row>
        <row>
          <cell>
            <formula>x^+</formula>
          </cell>
          <cell>
            <empty/>
          </cell>
          <cell>
            <formula>x^+</formula>
          </cell>
          <cell>
            <empty/>
          </cell>
          <cell>
            <formula>x^+</formula>
          </cell>
        </row>
        <row>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^+</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
          <cell>
            <formula>x^+</formula>
          </cell>
          <cell>
            <formula>x^\star</formula>
          </cell>
        </row>
      </table>
      <text>
        Associativity rules for <ldf:keyword>massage</ldf:keyword>:
      </text>
      <formula>x (yx)? = (xy)? x</formula>
      <formula>x (yx)^+ = (xy)^+ x</formula>
      <formula>x (yx)^\star = (xy)^\star x</formula>
    </content>
  </xldf:append>
  <xldf:add-subsection>
    <example id="massage-example">
      <content>
        <text>
          Distributivity rules for optionality modifier such as these:
        </text>
        <formula>(x? y?)? = x? y?</formula>
        <formula>(x^\star y?)? = x^\star y?</formula>
        <formula>(x? y^\star)? = x? y^\star</formula>
        <formula>(x^\star y^\star)? = x^\star y^\star</formula>
        <formula>(x | y)? = x? | y?</formula>
        <text>
          are not explicitly covered by <ldf:keyword>massage</ldf:keyword> since it is
          possible to emulate them with a sequence of abovementioned patterns of
          <ldf:keyword>massage</ldf:keyword>, as well as with <ldf:keyword>factor</ldf:keyword>
          and similar transformations. Let us take the last formula as an example of a massaging
          that takes several to complete.
          The input BGF is:
        </text>
      </content>
    </example>
    <to>element-massage</to>
  </xldf:add-subsection>
  <xldf:import-grammar>
    <target>massage-example</target>
    <file>../../transformation/xbgf/tests/massage_distr_ch.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>massage-example</where>
    <content>
      <text>After performing these transformation steps:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>massage-example</target>
    <file>../../transformation/xbgf/tests/massage_distr_ch.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>massage-example</where>
    <content>
      <text>The result will be:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>massage-example</target>
    <file>../../transformation/xbgf/tests/massage_distr_ch.baseline</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>massage-example</where>
    <content>
      <text>
        The selectors and <ldf:keyword>anonymize</ldf:keyword> commands are necessary
        because otherwise the choice of two epsilons would be removed automatically
        during the normalisation phase. The rest of distributivity laws are expressed
        quite similarly to this example.
      </text>
    </content>
  </xldf:append>

  <xldf:place>
    <section>element-distribute</section>
    <inside>group-refactoring-transformation</inside>
  </xldf:place>
  <xldf:add-subsection>
    <semantics>
      <content>
        <text>
          In fact, <ldf:keyword>distribute</ldf:keyword> is nothing more than an automated
          version of <ldf:keyword>factor</ldf:keyword> that agressively pushes all the choices
          that can be found in a production outwards.
        </text>
        <text>
          This transformation is apparently non-injective, hence, it is impossible to have
          a complete inverse of it. A more general <ldf:keyword>factor</ldf:keyword>
          transformation, on the other hand, is as capable of emulating <ldf:keyword>distribute</ldf:keyword>'s
          effect as it is capable of doing the reverse thing.
        </text>
      </content>
    </semantics>
    <to>element-distribute</to>
  </xldf:add-subsection>
  <xldf:add-subsection>
    <example id="distribute-example">
      <content>
        <text>For instance,</text>
      </content>
    </example>
    <to>element-distribute</to>
  </xldf:add-subsection>
  <xldf:import-grammar>
    <target>distribute-example</target>
    <file>../../transformation/xbgf/tests/distribute_nt.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>distribute-example</where>
    <content>
      <text>After using this transformation:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>distribute-example</target>
    <file>../../transformation/xbgf/tests/distribute_nt.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>distribute-example</where>
    <content>
      <text>Will look like this:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>distribute-example</target>
    <file>../../transformation/xbgf/tests/distribute_nt.baseline</file>
  </xldf:import-grammar>

  <xldf:place>
    <section>element-factor</section>
    <inside>group-refactoring-transformation</inside>
  </xldf:place>
  <xldf:add-subsection>
    <semantics>
      <content>
        <text>
          Factor transformations tend to be quite frequently used in grammar convergence.
          They also have a tendency to be very long---since it is impossible to implement
          <ldf:keyword>factor</ldf:keyword> symmetrically to <ldf:keyword>distribute</ldf:keyword>
          (i.e., fully automated), the language engineer needs to supply two complete
          expressions. The transformer then can easily assert that they are related by
          distribution: basically, it internally performs <ldf:keyword>distribute</ldf:keyword>
          on both of them and expects them to become identical. Hence, it is possible
          to do `incomplete' factoring by pushing choices inwards but not to the innermost
          position.
        </text>
        <text>
          Two most commonly seen patterns of <ldf:keyword>factor</ldf:keyword> use are the following.
          First, it is applied when we have a choice of two long expressions that are almost
          identical except for some mismatching part. That part can be either extracted
          or massaged later with more transformations. Second, it is needed when we have a wide
          choice with the same leading (or trailing) symbol, and the goal is to let the common
          part stay and encapsulate the rest inside a different nonterminal (by following
          <ldf:keyword>extract</ldf:keyword>).
        </text>
      </content>
    </semantics>
    <to>element-factor</to>
  </xldf:add-subsection>
  <xldf:add-subsection>
    <example id="factor-example">
      <content>
        <text>For instance,</text>
      </content>
    </example>
    <to>element-factor</to>
  </xldf:add-subsection>
  <xldf:import-grammar>
    <target>factor-example</target>
    <file>../../transformation/xbgf/tests/factor_local.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>factor-example</where>
    <content>
      <text>After using this transformation (note the order of expressions):</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>factor-example</target>
    <file>../../transformation/xbgf/tests/factor_local.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>factor-example</where>
    <content>
      <text>Will look like this:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>factor-example</target>
    <file>../../transformation/xbgf/tests/factor_local.baseline</file>
  </xldf:import-grammar>

  <xldf:place>
    <section>element-deyaccify</section>
    <inside>group-refactoring-transformation</inside>
  </xldf:place>
  <xldf:append>
    <where>element-deyaccify</where>
    <content>
      <text>
        Deyaccification uses several general patterns. Left recursion like this:
      </text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>element-deyaccify</target>
    <file>../../transformation/xbgf/tests/deyaccify_left.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>element-deyaccify</where>
    <content>
      <text>
        Becomes:
      </text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>element-deyaccify</target>
    <file>../../transformation/xbgf/tests/deyaccify_left.baseline</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>element-deyaccify</where>
    <content>
      <text>
        Right recursion like this:
      </text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>element-deyaccify</target>
    <file>../../transformation/xbgf/tests/deyaccify_right.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>element-deyaccify</where>
    <content>
      <text>
        Becomes:
      </text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>element-deyaccify</target>
    <file>../../transformation/xbgf/tests/deyaccify_right.baseline</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>element-deyaccify</where>
    <content>
      <text>
        In either case, it is checked if bar and wez are the same nonterminal.
        If they are, the result is more concise:
      </text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>element-deyaccify</target>
    <file>../../transformation/xbgf/tests/deyaccify_right_plus.baseline</file>
  </xldf:import-grammar>

  <xldf:place>
    <section>element-yaccify</section>
    <inside>group-refactoring-transformation</inside>
  </xldf:place>
  <xldf:add-subsection>
    <semantics>
      <content>
        <text>
          Yaccification is a typical example of grammar adaptation activity.
          However, it can be utilised in grammar convergence process as well:
          think of a situation when one of the sources is yaccified using left
          recursion while the other one---using right recursion. In such a case
          it would be better to deyaccify both of them. If this is due to some
          considerations impossible or undesirable, one can deyaccify, say,
          left recursion and then yaccify if back to right recursion.
        </text>
        <text>
          Since it is not possible for the transformation engine to guess which
          kind of BNF recursion the suite user would need, <ldf:keyword>yaccify</ldf:keyword>
          takes two productions as parameters, unlike <ldf:keyword>deyaccify</ldf:keyword>
          which works perfectly just given the nonterminal name.
        </text>
      </content>
    </semantics>
    <to>element-yaccify</to>
  </xldf:add-subsection>
  <xldf:add-subsection>
    <example id="yaccify-example">
      <content>
        <text>For instance, this piece of grammar:</text>
      </content>
    </example>
    <to>element-yaccify</to>
  </xldf:add-subsection>
  <xldf:import-grammar>
    <target>yaccify-example</target>
    <file>../../transformation/xbgf/tests/yaccify_left_plus.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>yaccify-example</where>
    <content>
      <text>can either be yaccified with left recursion:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>yaccify-example</target>
    <file>../../transformation/xbgf/tests/yaccify_left_plus.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>yaccify-example</where>
    <content>
      <text>to look like this:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>yaccify-example</target>
    <file>../../transformation/xbgf/tests/yaccify_left_plus.baseline</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>yaccify-example</where>
    <content>
      <text>or yaccified with right recursion:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>yaccify-example</target>
    <file>../../transformation/xbgf/tests/yaccify_right_plus.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>yaccify-example</where>
    <content>
      <text>to look like this:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>yaccify-example</target>
    <file>../../transformation/xbgf/tests/yaccify_right_plus.baseline</file>
  </xldf:import-grammar>

  <xldf:place>
    <section>element-eliminate</section>
    <inside>group-refactoring-transformation</inside>
  </xldf:place>
  <xldf:add-subsection>
    <example id="eliminate-example">
      <content>
        <text>For instance,</text>
      </content>
    </example>
    <to>element-eliminate</to>
  </xldf:add-subsection>
  <xldf:import-grammar>
    <target>eliminate-example</target>
    <file>../../transformation/xbgf/tests/eliminate.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>eliminate-example</where>
    <content>
      <text>After using this transformation:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>eliminate-example</target>
    <file>../../transformation/xbgf/tests/eliminate.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>eliminate-example</where>
    <content>
      <text>Will look like this:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>eliminate-example</target>
    <file>../../transformation/xbgf/tests/eliminate.baseline</file>
  </xldf:import-grammar>

  <xldf:place>
    <section>element-introduce</section>
    <inside>group-refactoring-transformation</inside>
  </xldf:place>
  <xldf:add-subsection>
    <example id="introduce-example">
      <content>
        <text>For instance,</text>
      </content>
    </example>
    <to>element-introduce</to>
  </xldf:add-subsection>
  <xldf:import-grammar>
    <target>introduce-example</target>
    <file>../../transformation/xbgf/tests/introduce.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>introduce-example</where>
    <content>
      <text>After using this transformation:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>introduce-example</target>
    <file>../../transformation/xbgf/tests/introduce.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>introduce-example</where>
    <content>
      <text>Will look like this:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>introduce-example</target>
    <file>../../transformation/xbgf/tests/introduce.baseline</file>
  </xldf:import-grammar>

  <xldf:place>
    <section>element-import</section>
    <inside>group-refactoring-transformation</inside>
  </xldf:place>
  <xldf:add-subsection>
    <semantics>
      <content>
        <text>
          There are times when <ldf:keyword>introduce</ldf:keyword> is just not enough.
          The simplest of such a situations is a case when we want to introduce two
          productions, each defining a fresh nonterminal symbol, and each using the other.
          Without <ldf:keyword>import</ldf:keyword> the only way to do it was to run one
          <ldf:keyword>introduce</ldf:keyword> and one <ldf:keyword>define</ldf:keyword>,
          which is semantically wrong since we are sure that before the first nonterminal
          is introduced, the second one was fresh. So, instead we take the interdependent
          productions together and introduce them in one step.
        </text>
        <text>
          Technically, <ldf:keyword>import</ldf:keyword> can be used any time to
          substitute any number of <ldf:keyword>introduce</ldf:keyword> transformations.
        </text>
      </content>
    </semantics>
    <to>element-import</to>
  </xldf:add-subsection>
  <xldf:add-subsection>
    <example id="import-example">
      <content>
        <text>For instance,</text>
      </content>
    </example>
    <to>element-import</to>
  </xldf:add-subsection>
  <xldf:import-grammar>
    <target>import-example</target>
    <file>../../transformation/xbgf/tests/import.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>import-example</where>
    <content>
      <text>After using this transformation:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>import-example</target>
    <file>../../transformation/xbgf/tests/import.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>import-example</where>
    <content>
      <text>It will look like this:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>import-example</target>
    <file>../../transformation/xbgf/tests/import.baseline</file>
  </xldf:import-grammar>

  <xldf:place>
    <section>element-vertical</section>
    <inside>group-refactoring-transformation</inside>
  </xldf:place>
  <xldf:add-subsection>
    <example id="vertical-example">
      <content>
        <text>If the original production contained selectors:</text>
      </content>
    </example>
    <to>element-vertical</to>
  </xldf:add-subsection>
  <xldf:import-grammar>
    <target>vertical-example</target>
    <file>../../transformation/xbgf/tests/vertical_s.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>vertical-example</where>
    <content>
      <text>the, after using this transformation:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>vertical-example</target>
    <file>../../transformation/xbgf/tests/vertical_s.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>vertical-example</where>
    <content>
      <text>they are converted to labels:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>vertical-example</target>
    <file>../../transformation/xbgf/tests/vertical_s.baseline</file>
  </xldf:import-grammar>

  <xldf:place>
    <section>element-horizontal</section>
    <inside>group-refactoring-transformation</inside>
  </xldf:place>
  <xldf:add-subsection>
    <example id="horizontal-example">
      <content>
        <text>If some or all of the original productions are labelled:</text>
      </content>
    </example>
    <to>element-horizontal</to>
  </xldf:add-subsection>
  <xldf:import-grammar>
    <target>horizontal-example</target>
    <file>../../transformation/xbgf/tests/horizontal_l.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>horizontal-example</where>
    <content>
      <text>the, after using this transformation:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>horizontal-example</target>
    <file>../../transformation/xbgf/tests/horizontal_l.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>horizontal-example</where>
    <content>
      <text>each label is converted to a selector in a corresponding place:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>horizontal-example</target>
    <file>../../transformation/xbgf/tests/horizontal_l.baseline</file>
  </xldf:import-grammar>

  <xldf:place>
    <section>element-rassoc</section>
    <inside>group-refactoring-transformation</inside>
  </xldf:place>
  <xldf:add-subsection>
    <example id="rassoc-example">
      <content>
        <text>For instance,</text>
      </content>
    </example>
    <to>element-rassoc</to>
  </xldf:add-subsection>
  <xldf:import-grammar>
    <target>rassoc-example</target>
    <file>../../transformation/xbgf/tests/rassoc_s.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>rassoc-example</where>
    <content>
      <text>After using this transformation:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>rassoc-example</target>
    <file>../../transformation/xbgf/tests/rassoc_s.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>rassoc-example</where>
    <content>
      <text>Will look like this:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>rassoc-example</target>
    <file>../../transformation/xbgf/tests/rassoc_s.baseline</file>
  </xldf:import-grammar>
  
  <xldf:place>
    <section>element-lassoc</section>
    <inside>group-refactoring-transformation</inside>
  </xldf:place>
  <xldf:add-subsection>
    <example id="lassoc-example">
      <content>
        <text>For instance,</text>
      </content>
    </example>
    <to>element-lassoc</to>
  </xldf:add-subsection>
  <xldf:import-grammar>
    <target>lassoc-example</target>
    <file>../../transformation/xbgf/tests/lassoc_p.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>lassoc-example</where>
    <content>
      <text>After using this transformation:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>lassoc-example</target>
    <file>../../transformation/xbgf/tests/lassoc_p.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>lassoc-example</where>
    <content>
      <text>Will look like this:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>lassoc-example</target>
    <file>../../transformation/xbgf/tests/lassoc_p.baseline</file>
  </xldf:import-grammar>

  <xldf:change-role>
    <scope>group-refactoring-transformation</scope>
    <from>syntax</from>
    <to>synopsis</to>
  </xldf:change-role>

</xldf:evolution-sequence>