<?xml version="1.0" encoding="utf-8"?>
<xldf:sequence
  xmlns:bgf="http://planet-sl.org/bgf"
  xmlns:xbgf="http://planet-sl.org/xbgf"
  xmlns:ldf="http://planet-sl.org/ldf"
  xmlns:xldf="http://planet-sl.org/xldf">

  <!-- compose a section on folding transformations -->
  <xldf:rename>
    <from>
      <title>folding-transformation</title>
    </from>
    <to>Folding and unfolding transformations</to>
  </xldf:rename>
  <xldf:place>
    <section>element-unfold</section>
    <inside>group-folding-transformation</inside>
  </xldf:place>
  <xldf:insert>
    <before>
      <text>
        The definition that is being unfolded is assumed to be horisontal
        (see the section on refactorings for more information about horisontal
        and vertical definitions).
      </text>
    </before>
    <content>
      <text>
        Almost all the <ldf:keyword>unfold</ldf:keyword> transformations used in Java
        Language Specification case study are restricted in scope by a nonterminal.
        The reason for such statistics is that when the language engineer wants to
        give up the nonterminal, he uses the <ldf:keyword>inline</ldf:keyword>
        transformations. On the other hand, <ldf:keyword>unfold</ldf:keyword> usually
        happens as a part of sequences with <ldf:keyword>fold</ldf:keyword>,
        <ldf:keyword>downgrade</ldf:keyword>, <ldf:keyword>disappear</ldf:keyword>,
        <ldf:keyword>deyaccify</ldf:keyword>, <ldf:keyword>distribute</ldf:keyword>,
        etc.---in which case it is only natural to try to limit the impact of every
        step.
      </text>
    </content>
  </xldf:insert>
  <xldf:add-subsection>
    <example id="unfold-example">
      <content>
        <text>Given the input:</text>
      </content>
    </example>
    <to>element-unfold</to>
  </xldf:add-subsection>
  
  <xldf:import-grammar>
    <target>unfold-example</target>
    <file>../../transformation/xbgf/tests/unfold.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>unfold-example</where>
    <content>
      <text>After using this transformation:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>unfold-example</target>
    <file>../../transformation/xbgf/tests/unfold.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>unfold-example</where>
    <content>
      <text>Will look like this:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>unfold-example</target>
    <file>../../transformation/xbgf/tests/unfold.baseline</file>
  </xldf:import-grammar>

  <xldf:place>
    <section>element-fold</section>
    <inside>group-folding-transformation</inside>
  </xldf:place>
  <xldf:add-subsection>
    <example id="fold-example">
      <content>
      <text>Very much like unfolding, folding can take place locally. For example,</text>
    </content>
    </example>
    <to>element-fold</to>
  </xldf:add-subsection>
  <xldf:import-grammar>
    <target>fold-example</target>
    <file>../../transformation/xbgf/tests/fold_nt.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>fold-example</where>
    <content>
      <text>After using this transformation:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>fold-example</target>
    <file>../../transformation/xbgf/tests/fold_nt.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>fold-example</where>
    <content>
      <text>Will look like this:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>fold-example</target>
    <file>../../transformation/xbgf/tests/fold_nt.baseline</file>
  </xldf:import-grammar>
  
  <xldf:place>
    <section>element-inline</section>
    <inside>group-folding-transformation</inside>
  </xldf:place>
  <xldf:add-subsection>
    <considerations>
      <content>
        <text>
          The <ldf:keyword>inline</ldf:keyword> transformation is by far the
          most used in Java Language Specification case. One of the reasons
          is what we call layering: in particular expressions and statements
          are introduced in the $G_j^R$ with a set of related nonterminals:
          LabeledStatement, IfThenElseStatement, WhileStatement, ForStatement, etc, and
          CastExpression, PreIncrementExpression, PreDecrementExpression, PostfixExpression, etc.
          $G_j^I$ takes another approach, just listing all the alternatives in the productions
          for Statement and Expression. In order to converge these two variants, a lot of inlining
          transformations are needed. This can also be apparent from the statistics table,
          that demonstrates that targets that converge only `readable' grammars require up to
          ten inline transformations each, while each target that takes both readable and
          implementable grammars in, contains 70--100 <ldf:keyword>inline</ldf:keyword>
          transformations in convergence path.
        </text>
      </content>
    </considerations>
    <to>element-inline</to>
  </xldf:add-subsection>
  <xldf:add-subsection>
    <example id="inline-example">
      <content>
        <text>An example follows. When we have:</text>
      </content>
    </example>
    <to>element-inline</to>
  </xldf:add-subsection>
  <xldf:import-grammar>
    <target>inline-example</target>
    <file>../../transformation/xbgf/tests/inline.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>inline-example</where>
    <content>
      <text>After using this transformation:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>inline-example</target>
    <file>../../transformation/xbgf/tests/inline.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>inline-example</where>
    <content>
      <text>It will look like this:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>inline-example</target>
    <file>../../transformation/xbgf/tests/inline.baseline</file>
  </xldf:import-grammar>
  
  <xldf:place>
    <section>element-extract</section>
    <inside>group-folding-transformation</inside>
  </xldf:place>
  <xldf:add-subsection>
    <considerations>
      <content>
        <text>
          As seen from the experience gained from Java Language Specification case,
          it is highly unusual for extract to have limited scope. However, sometimes
          a limited impact is desired in order to avoid excessive subsequent unfoldings
          when the convergence requests for having several nonterminals with similar
          definitions.
        </text>
      </content>
    </considerations>
    <to>element-extract</to>
  </xldf:add-subsection>
  <xldf:add-subsection>
    <example id="extract-example">
      <content>
        <text>
          Extraction also works vertically. Given the input:
        </text>
      </content>
    </example>
    <to>element-extract</to>
  </xldf:add-subsection>
  <xldf:import-grammar>
    <target>extract-example</target>
    <file>../../transformation/xbgf/tests/extract_subch.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>extract-example</where>
    <content>
      <text>After performing this transformation step:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>extract-example</target>
    <file>../../transformation/xbgf/tests/extract_subch.xbgf</file>
    <prettyprinter>../../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>extract-example</where>
    <content>
      <text>The result will be:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>extract-example</target>
    <file>../../transformation/xbgf/tests/extract_subch.baseline</file>
  </xldf:import-grammar>

  <xldf:place>
    <section>element-abridge</section>
    <inside>group-folding-transformation</inside>
  </xldf:place>
  <xldf:add-subsection>
    <considerations>
      <content>
        <text>
          Reflexive chain productions are rarely encountered explicitly, so it calls for more clear explanation.
          However, after a series of transformations one can arrive at the point of having such
          a production and, quite naturally, wanting to get rid of it. An example of a transformation
          sequence that yields a reflexive chain production can be a step from concrete syntax definition
          to abstract syntax definition. Concrete syntax usually needs explicit bracketing constructions for
          recursive composition, and after stripping away terminals and merging layers, these bracketing
          constructions become reflexive chain productions. The Factorial Language case has shown the need
          for it.
        </text>
      </content>
    </considerations>
    <to>element-abridge</to>
  </xldf:add-subsection>
  
  <xldf:place>
    <section>element-detour</section>
    <inside>group-folding-transformation</inside>
  </xldf:place>
  <xldf:place>
    <section>element-unchain</section>
    <inside>group-folding-transformation</inside>
  </xldf:place>
  <xldf:place>
    <section>element-chain</section>
    <inside>group-folding-transformation</inside>
  </xldf:place>

</xldf:sequence>