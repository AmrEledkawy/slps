<?xml version="1.0" encoding="utf-8"?>
<xldf:sequence
  xmlns:bgf="http://planet-sl.org/bgf"
  xmlns:xbgf="http://planet-sl.org/xbgf"
  xmlns:ldf="http://planet-sl.org/ldf"
  xmlns:xldf="http://planet-sl.org/xldf">

  <!-- compose a section on folding transformations -->
  <xldf:rename>
    <from>
      <title>folding-transformation</title>
    </from>
    <to>Folding and unfolding transformations</to>
  </xldf:rename>
  <xldf:place>
    <section>element-unfold</section>
    <inside>group-folding-transformation</inside>
  </xldf:place>
  <xldf:insert>
    <before>
      <text>
        The definition that is being unfolded is assumed to be horisontal
        (see the section on refactorings for more information about horisontal
        and vertical definitions).
      </text>
    </before>
    <content>
      <text>
        Almost all the <ldf:keyword>unfold</ldf:keyword> transformations used in Java
        Language Specification case study are restricted in scope by a nonterminal.
        The reason for such statistics is that when the language engineer wants to
        give up the nonterminal, he uses the <ldf:keyword>inline</ldf:keyword>
        transformations. On the other hand, <ldf:keyword>unfold</ldf:keyword> usually
        happens as a part of sequences with <ldf:keyword>fold</ldf:keyword>,
        <ldf:keyword>downgrade</ldf:keyword>, <ldf:keyword>disappear</ldf:keyword>,
        <ldf:keyword>deyaccify</ldf:keyword>, <ldf:keyword>distribute</ldf:keyword>,
        etc.---in which case it is only natural to try to limit the impact of every
        step.
      </text>
    </content>
  </xldf:insert>
 
  
  <xldf:import-grammar>
    <target>element-unfold</target>
    <file>../transformation/xbgf/tests/unfold.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>element-unfold</where>
    <content>
      <text>After using this transformation:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>element-unfold</target>
    <file>../transformation/xbgf/tests/unfold.xbgf</file>
    <prettyprinter>../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>element-unfold</where>
    <content>
      <text>Will look like this:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>element-unfold</target>
    <file>../transformation/xbgf/tests/unfold.baseline</file>
  </xldf:import-grammar>

  <xldf:place>
    <section>element-fold</section>
    <inside>group-folding-transformation</inside>
  </xldf:place>
  <xldf:append>
    <where>element-fold</where>
    <content>
      <text>Very much like unfolding, folding can take place locally. For example,</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>element-fold</target>
    <file>../transformation/xbgf/tests/fold_nt.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>element-fold</where>
    <content>
      <text>After using this transformation:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>element-fold</target>
    <file>../transformation/xbgf/tests/fold_nt.xbgf</file>
    <prettyprinter>../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>element-fold</where>
    <content>
      <text>Will look like this:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>element-fold</target>
    <file>../transformation/xbgf/tests/fold_nt.baseline</file>
  </xldf:import-grammar>
  
  <xldf:place>
    <section>element-inline</section>
    <inside>group-folding-transformation</inside>
  </xldf:place>
  <xldf:append>
    <where>element-inline</where>
    <content>
      <text>
        The inline transformation is by far the most used in Java Language Specification
        case. One of the reasons is what we call layering: in particular expressions
        and statements are introduced in the $G_j^R$ with a set of related nonterminals:
        LabeledStatement, IfThenElseStatement, WhileStatement, ForStatement, etc, and
        CastExpression, PreIncrementExpression, PreDecrementExpression, PostfixExpression, etc.
        $G_j^I$ takes another approach, just listing all the alternatives in the productions
        for Statement and Expression. In order to converge these two variants, a lot of inlining
        transformations are needed. This can also be apparent from the statistics table,
        that demonstrates that targets that converge only `readable' grammars require up to
        ten inline transformations each, while each target that takes both readable and
        implementable grammars in, contains 70--100 <ldf:keyword>inline</ldf:keyword>
        transformations in convergence path.
      </text>
      <text>An example follows. When we have:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>element-inline</target>
    <file>../transformation/xbgf/tests/inline.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>element-inline</where>
    <content>
      <text>After using this transformation:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>element-inline</target>
    <file>../transformation/xbgf/tests/inline.xbgf</file>
    <prettyprinter>../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>element-inline</where>
    <content>
      <text>It will look like this:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>element-inline</target>
    <file>../transformation/xbgf/tests/inline.baseline</file>
  </xldf:import-grammar>
  
  <xldf:place>
    <section>element-extract</section>
    <inside>group-folding-transformation</inside>
  </xldf:place>
  <xldf:append>
    <where>element-extract</where>
    <content>
      <text>
        As seen from the experience gained from Java Language Specification case,
        it is highly unusual for extract to have limited scope. However, sometimes
        a limited impact is desired in order to avoid excessive subsequent unfoldings
        when the convergence requests for having several nonterminals with similar
        definitions.
      </text>
      <text>
        <ldf:keyword>Extract</ldf:keyword> also works vertically. Given the input:
      </text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>element-extract</target>
    <file>../transformation/xbgf/tests/extract_subch.bgf</file>
  </xldf:import-grammar>
  <xldf:append>
    <where>element-extract</where>
    <content>
      <text>After performing this transformation step:</text>
    </content>
  </xldf:append>
  <xldf:import-sample>
    <target>element-extract</target>
    <file>../transformation/xbgf/tests/extract_subch.xbgf</file>
    <prettyprinter>../../shared/tools/xbgf2xbnf</prettyprinter>
  </xldf:import-sample>
  <xldf:append>
    <where>element-extract</where>
    <content>
      <text>The result will be:</text>
    </content>
  </xldf:append>
  <xldf:import-grammar>
    <target>element-extract</target>
    <file>../transformation/xbgf/tests/extract_subch.baseline</file>
  </xldf:import-grammar>

  <xldf:place>
    <section>element-abridge</section>
    <inside>group-folding-transformation</inside>
  </xldf:place>
  <xldf:append>
    <where>element-abridge</where>
    <content>
      <text>
        Reflexive chain productions are rarely encountered explicitly, so it calls for more clear explanation.
        However, after a series of transformations one can arrive at the point of having such
        a production and, quite naturally, wanting to get rid of it. An example of a transformation
        sequence that yields a reflexive chain production can be a step from concrete syntax definition
        to abstract syntax definition. Concrete syntax usually needs explicit bracketing constructions for
        recursive composition, and after stripping away terminals and merging layers, these bracketing
        constructions become reflexive chain productions. The Factorial Language case has shown the need
        for it.
      </text>
    </content>
  </xldf:append>
  <xldf:place>
    <section>element-detour</section>
    <inside>group-folding-transformation</inside>
  </xldf:place>
  <xldf:place>
    <section>element-unchain</section>
    <inside>group-folding-transformation</inside>
  </xldf:place>
  <xldf:place>
    <section>element-chain</section>
    <inside>group-folding-transformation</inside>
  </xldf:place>

</xldf:sequence>