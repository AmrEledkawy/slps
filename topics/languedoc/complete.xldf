<?xml version="1.0" encoding="utf-8"?>
<xldf:sequence
  xmlns:bgf="http://planet-sl.org/bgf"
  xmlns:xbgf="http://planet-sl.org/xbgf"
  xmlns:xldf="http://planet-sl.org/xldf">

  <xldf:insert>
    <after>
      <p>
        There are two expression arguments: one to be matched, and another one that
        replaces the matched expression. One of them must be in a "massage relation" to
        the other.
      </p>
    </after>
    <content>
      <p>The massage relation is defined as follows:</p>
      <formula>(x^+)? = x^\star</formula>
      <formula>(x^\star)? = x^\star</formula>
      <formula>(x?)? = x?</formula>
      <formula>(x^\star)^\star = x^\star</formula>
      <formula>(x^+)^\star = x^\star</formula>
      <formula>(x?)^\star = x^\star</formula>
      <formula>(x^+)^+ = x^+</formula>
      <formula>(x^\star)^+ = x^\star</formula>
      <formula>(x?)^+ = x^\star</formula>
      <p>The following formulae are more complicated examples of masssage:</p>
      <formula>x|\varepsilon   = x?</formula>
      <formula>x|x = x</formula>
      <formula>x^+|\varepsilon  = x^\star</formula>
      <formula>x^+|x? = x^\star</formula>
      <formula>x x^\star = x^+</formula>
      <formula>x (yx)^\star = (xy)^\star x</formula>
      <formula>x (yx)^+ = (xy)^+ x</formula>
      <p>Another rule that is harder to express is when</p>
      <formula>x? = x</formula>
      <p>in the cases when x is optional anyway, i.e. it is one of the following:</p>
      <formula>\varepsilon|...</formula>
      <formula>y?</formula>
      <formula>y^\star</formula>
      <formula>y|...</formula>
      <formula>y z ...</formula>
      <p>where y and z are also recursively optional anyway.</p>
    </content>
  </xldf:insert>

  <!-- compose a section on folding transformations -->
  <xldf:rename>
    <from>
      <title>foldingtransformation</title>
    </from>
    <to>Folding and unfolding transformations</to>
  </xldf:rename>
  <xldf:move>
    <section>element-unfold</section>
    <inside>group-foldingtransformation</inside>
  </xldf:move>
  <xldf:insert>
    <before>
      <p>
        The definition that is being unfolded is assumed to be horisontal
        (see the section on refactorings for more information about horisontal
        and vertical definitions).
      </p>
    </before>
    <content>
      <p>
        Almost all the unfold transformations used in Java Language Specification
        case are restricted in scope by a nonterminal. The reason for such statistics
        is that when the language engineer wants to give up the nonterminal, he uses
        the inline transformations. On the other hand, unfold usually happens as a
        part of sequences with fold, downgrade, disappear, deyaccify, distribute,
        etc.---in which case it is only natural to try to limit the impact of every
        step.
      </p>
    </content>
  </xldf:insert>
  <xldf:move>
    <section>element-fold</section>
    <inside>group-foldingtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-inline</section>
    <inside>group-foldingtransformation</inside>
  </xldf:move>
  <xldf:append>
    <where>element-inline</where>
    <content>
      <p>
        The inline transformation is by far the most used in Java Language Specification
        case. One of the reasons is what we call layering: in particular expressions
        and statements are introduced in the $G_j^R$ with a set of related nonterminals:
        LabeledStatement, IfThenElseStatement, WhileStatement, ForStatement, etc, and
        CastExpression, PreIncrementExpression, PreDecrementExpression, PostfixExpression, etc.
        $G_j^I$ takes another approach, just listing all the alternatives in the productions
        for Statement and Expression. In order to converge these two variants, a lot of inline
        transformations are needed. This can also be apparent from the statistics table,
        that demonstrates that targets that converge only `readable' grammars require up to
        ten inline transformations each, while each target that takes both readable and
        implementable grammars in, contains 70--100 inline transformations in convergence path.
      </p>
    </content>
  </xldf:append>
  <xldf:move>
    <section>element-extract</section>
    <inside>group-foldingtransformation</inside>
  </xldf:move>
  <xldf:append>
    <where>element-extract</where>
    <content>
      <p>
        As seen from the experience gained from Java Language Specification case,
        it is highly unusual for extract to have limited scope. However, sometimes
        a limited impact is desired in order to avoid excessive subsequent unfoldings
        when the convergence requests for having several nonterminals with similar
        definitions.
      </p>
    </content>
  </xldf:append>
  <xldf:move>
    <section>element-abridge</section>
    <inside>group-foldingtransformation</inside>
  </xldf:move>
  <xldf:append>
    <where>element-abridge</where>
    <content>
      <p>
        Reflexive chain productions are rarely encountered explicitly, so it calls for more clear explanation.
        However, after a series of transformations one can arrive at the point of having such
        a production and, quite naturally, wanting to get rid of it. An example of a transformation
        sequence that yields a reflexive chain production can be a step from concrete syntax definition
        to abstract syntax definition. Concrete syntax usually needs explicit bracketing constructions for
        recursive composition, and after stripping away terminals and merging layers, these bracketing
        constructions become reflexive chain productions. The Factorial Language case has shown the need
        for it.
      </p>
    </content>
  </xldf:append>
  <xldf:move>
    <section>element-detour</section>
    <inside>group-foldingtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-unchain</section>
    <inside>group-foldingtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-chain</section>
    <inside>group-foldingtransformation</inside>
  </xldf:move>

  <!-- compose a section on refactoring transformations -->
  <xldf:rename>
    <from>
      <title>refactoringtransformation</title>
    </from>
    <to>Other refactoring transformations</to>
  </xldf:rename>
  <xldf:move>
    <section>element-massage</section>
    <inside>group-refactoringtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-factor</section>
    <inside>group-refactoringtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-distribute</section>
    <inside>group-refactoringtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-deyaccify</section>
    <inside>group-refactoringtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-yaccify</section>
    <inside>group-refactoringtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-eliminate</section>
    <inside>group-refactoringtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-introduce</section>
    <inside>group-refactoringtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-import</section>
    <inside>group-refactoringtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-vertical</section>
    <inside>group-refactoringtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-horizontal</section>
    <inside>group-refactoringtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-rassoc</section>
    <inside>group-refactoringtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-lassoc</section>
    <inside>group-refactoringtransformation</inside>
  </xldf:move>

  <!-- compose a section on increasing transformations -->
  <xldf:rename>
    <from>
      <title>increasingtransformation</title>
    </from>
    <to>Grammar lengthening transformations</to>
  </xldf:rename>
  <xldf:move>
    <section>element-add</section>
    <inside>group-increasingtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-appear</section>
    <inside>group-increasingtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-widen</section>
    <inside>group-increasingtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-upgrade</section>
    <inside>group-increasingtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-unite</section>
    <inside>group-increasingtransformation</inside>
  </xldf:move>

  <!-- compose a section on decreasing transformations -->
  <xldf:rename>
    <from>
      <title>decreasingtransformation</title>
    </from>
    <to>Grammar shortening transformations</to>
  </xldf:rename>
  <xldf:move>
    <section>element-remove</section>
    <inside>group-decreasingtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-disappear</section>
    <inside>group-decreasingtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-narrow</section>
    <inside>group-decreasingtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-downgrade</section>
    <inside>group-decreasingtransformation</inside>
  </xldf:move>

  <!-- compose a section on abstract revising transformations -->
  <xldf:rename>
    <from>
      <title>concreterevisingtransformation</title>
    </from>
    <to>Semantics revising transformations that preserve abstract semantics</to>
  </xldf:rename>
  <xldf:move>
    <section>element-abstractize</section>
    <inside>group-concreterevisingtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-concretize</section>
    <inside>group-concreterevisingtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-permute</section>
    <inside>group-concreterevisingtransformation</inside>
  </xldf:move>

  <!-- compose a section on concrete revising transformations -->
  <xldf:rename>
    <from>
      <title>abstractrevisingtransformation</title>
    </from>
    <to>Stronger semantics revising transformations</to>
  </xldf:rename>
  <xldf:move>
    <section>element-define</section>
    <inside>group-abstractrevisingtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-undefine</section>
    <inside>group-abstractrevisingtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-redefine</section>
    <inside>group-abstractrevisingtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-inject</section>
    <inside>group-abstractrevisingtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-project</section>
    <inside>group-abstractrevisingtransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-replace</section>
    <inside>group-abstractrevisingtransformation</inside>
  </xldf:move>

  <!-- compose a section on decorative transformations -->
  <xldf:rename>
    <from>
      <title>decorativetransformation</title>
    </from>
    <to>Decorative transformations</to>
  </xldf:rename>
  <xldf:move>
    <section>element-designate</section>
    <inside>group-decorativetransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-unlabel</section>
    <inside>group-decorativetransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-anonymize</section>
    <inside>group-decorativetransformation</inside>
  </xldf:move>
  <xldf:move>
    <section>element-deanonymize</section>
    <inside>group-decorativetransformation</inside>
  </xldf:move>


  <!-- <mml:math xmlns:mml="http://www.w3.org/1998/Math/MathML"
	          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	          xsi:schemaLocation="http://www.w3.org/1998/Math/MathML
	            http://www.w3.org/Math/XMLSchema/mathml2/mathml2.xsd">
	<mrow>
	<mrow><mfenced><msup><mi>x</mi><mo>^+</mo></msup><mfenced><mo>?</mo></mrow>
	<mo>=</mo>
	<msup><mi>x</mi><mo>^\star</mo></msup>
	</mrow>
	</mml:math>-->
</xldf:sequence>
